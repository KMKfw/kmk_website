"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[2506],{3905:function(x,e,n){n.d(e,{Zo:function(){return l},kt:function(){return s}});var r=n(7294);function o(x,e,n){return e in x?Object.defineProperty(x,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):x[e]=n,x}function t(x,e){var n=Object.keys(x);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(x);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(x,e).enumerable}))),n.push.apply(n,r)}return n}function a(x){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?t(Object(n),!0).forEach((function(e){o(x,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(x,Object.getOwnPropertyDescriptors(n)):t(Object(n)).forEach((function(e){Object.defineProperty(x,e,Object.getOwnPropertyDescriptor(n,e))}))}return x}function _(x,e){if(null==x)return{};var n,r,o=function(x,e){if(null==x)return{};var n,r,o={},t=Object.keys(x);for(r=0;r<t.length;r++)n=t[r],e.indexOf(n)>=0||(o[n]=x[n]);return o}(x,e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(x);for(r=0;r<t.length;r++)n=t[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(x,n)&&(o[n]=x[n])}return o}var d=r.createContext({}),i=function(x){var e=r.useContext(d),n=e;return x&&(n="function"==typeof x?x(e):a(a({},e),x)),n},l=function(x){var e=i(x.components);return r.createElement(d.Provider,{value:e},x.children)},c={inlineCode:"code",wrapper:function(x){var e=x.children;return r.createElement(r.Fragment,{},e)}},C=r.forwardRef((function(x,e){var n=x.components,o=x.mdxType,t=x.originalType,d=x.parentName,l=_(x,["components","mdxType","originalType","parentName"]),C=i(n),s=o,u=C["".concat(d,".").concat(s)]||C[s]||c[s]||t;return n?r.createElement(u,a(a({ref:e},l),{},{components:n})):r.createElement(u,a({ref:e},l))}));function s(x,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof x||o){var t=n.length,a=new Array(t);a[0]=C;var _={};for(var d in e)hasOwnProperty.call(e,d)&&(_[d]=e[d]);_.originalType=x,_.mdxType="string"==typeof x?x:o,a[1]=_;for(var i=2;i<t;i++)a[i]=n[i];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}C.displayName="MDXCreateElement"},9382:function(x,e,n){n.r(e),n.d(e,{assets:function(){return l},contentTitle:function(){return d},default:function(){return s},frontMatter:function(){return _},metadata:function(){return i},toc:function(){return c}});var r=n(7462),o=n(3366),t=(n(7294),n(3905)),a=["components"],_={},d="Encoder module",i={unversionedId:"encoder",id:"encoder",title:"Encoder module",description:"Add twist control to your keyboard! Volume, zoom, anything you want",source:"@site/docs/encoder.md",sourceDirName:".",slug:"/encoder",permalink:"/docs/encoder",draft:!1,editUrl:"https://github.com/KMKfw/kmk_firmware/tree/master/docs/encoder.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"AS5013 (aka 'EasyPoint')",permalink:"/docs/easypoint"},next:{title:"Status LEDs",permalink:"/docs/extension_statusled"}},l={},c=[{value:"Enabling the extension",id:"enabling-the-extension",level:2},{value:"How to use",id:"how-to-use",level:2},{value:"Full example (with 1 encoder)",id:"full-example-with-1-encoder",level:2}],C={toc:c};function s(x){var e=x.components,n=(0,o.Z)(x,a);return(0,t.kt)("wrapper",(0,r.Z)({},C,n,{components:e,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"encoder-module"},"Encoder module"),(0,t.kt)("p",null,"Add twist control to your keyboard! Volume, zoom, anything you want"),(0,t.kt)("p",null,"I2C encoder type has been tested with the Adafruit I2C QT Rotary Encoder with NeoPixel"),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Note:")," If split with encoders and both sides should work, it's currently necessary to use the encoder-scanner explained at the bottom of ",(0,t.kt)("a",{parentName:"p",href:"/docs/scanners"},"scanners docs"),"."),(0,t.kt)("h2",{id:"enabling-the-extension"},"Enabling the extension"),(0,t.kt)("p",null,"The constructor(",(0,t.kt)("inlineCode",{parentName:"p"},"EncoderHandler")," class) takes a list of encoder, each one defined as either:"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"a list of pad_a pin, pad_b pin, button_pin and optionally a flag set to True is you want it to be reversed"),(0,t.kt)("li",{parentName:"ul"},"a ",(0,t.kt)("inlineCode",{parentName:"li"},"busio.I2C"),", address and optionally a flag set to True if you want it to be reversed")),(0,t.kt)("p",null,'The encoder_map is modeled after the keymap and works the same way. It should have as many layers (key pressed on "turned left", key pressed on "turned right", key pressed on "knob pressed") as your keymap, and use KC.NO keys for layers that you don\'t require any action.\nThe encoder supports a velocity mode if you desire to make something for video or sound editing. '),(0,t.kt)("h2",{id:"how-to-use"},"How to use"),(0,t.kt)("p",null,"How to use this module in your main / code file"),(0,t.kt)("ol",null,(0,t.kt)("li",{parentName:"ol"},"load the module")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"from kmk.modules.encoder import EncoderHandler\nencoder_handler = EncoderHandler()\nkeyboard.modules = [layers, modtap, encoder_handler]\n")),(0,t.kt)("ol",{start:2},(0,t.kt)("li",{parentName:"ol"},"Define the pins for each encoder (pin_a, pin_b, pin_button ","[or ",(0,t.kt)("inlineCode",{parentName:"li"},"None")," if the encoder's button is handled differently or not at all]",", True for an inversed encoder)")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"#GPIO Encoder\nencoder_handler.pins = ((board.GP17, board.GP15, board.GP14, False), (encoder 2 definition), etc. )\n")),(0,t.kt)("p",null,"OR"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"# I2C Encoder\n\n# Setup i2c\nSDA = board.GP0\nSCL = board.GP1\ni2c = busio.I2C(SCL, SDA)\n\nencoder_handler.pins = ((i2c, 0x36, False),)\n")),(0,t.kt)("ol",{start:3},(0,t.kt)("li",{parentName:"ol"},"Define the mapping of keys to be called (1 / layer)")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"# You can optionally predefine combo keys as for your layout\nZoom_in = KC.LCTRL(KC.EQUAL)\nZoom_out = KC.LCTRL(KC.MINUS)\n\n\nencoder_handler.map = [(( KC.VOLD, KC.VOLU, KC.MUTE),(encoder 2 definition), etc. ), # Layer 1\n                      ((KC.Zoom_out, KC.Zoom_in, KC.NO),(encoder 2 definition), etc. ), # Layer 2\n                      ((KC.A, KC.Z, KC.N1),(encoder 2 definition), etc. ), # Layer 3\n                      ((KC.NO, KC.NO, KC.NO),(encoder 2 definition), etc. ), # Layer 4\n                      ]\n")),(0,t.kt)("ol",{start:4},(0,t.kt)("li",{parentName:"ol"},"Encoder methods on_move_do and on_button_do can be overwritten for complex use cases")),(0,t.kt)("h2",{id:"full-example-with-1-encoder"},"Full example (with 1 encoder)"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'import board\n\nfrom kmk.kmk_keyboard import KMKKeyboard\nfrom kmk.consts import UnicodeMode\nfrom kmk.keys import KC\nfrom kmk.scanners import DiodeOrientation\nfrom kmk.modules.layers import Layers\nfrom kmk.modules.encoder import EncoderHandler\n\n\nkeyboard = KMKKeyboard()\nlayers = Layers()\nencoder_handler = EncoderHandler()\nkeyboard.modules = [layers, encoder_handler]\n\n\nkeyboard.col_pins = (\n    board.GP0, board.GP1, board.GP2, board.GP3, board.GP4, board.GP5,\n    board.GP6, board.GP7, board.GP8, board.GP9, board.GP10, board.GP11,\n    board.GP12, board.GP13,\n)\nkeyboard.row_pins = (board.GP28, board.GP27, board.GP22, board.GP26, board.GP21)\nkeyboard.diode_orientation = DiodeOrientation.COLUMNS\n\n# I2C example\n#import busio\n#SDA = board.GP0\n#SCL = board.GP1\n#i2c = busio.I2C(SCL, SDA)\n#encoder_handler.i2c = ((i2c, 0x36, False),)\n\nencoder_handler.pins = ((board.GP17, board.GP15, board.GP14, False),)\n\nkeyboard.tap_time = 250\nkeyboard.debug_enabled = False\n\n\n# Filler keys\n_______ = KC.TRNS\nxxxxxxx = KC.NO\ntbdtbd = KC.A\n\n\n# Layers\nLYR_STD, LYR_EXT, LYR_NUM, LYR_GAME = 0, 1, 2, 3\n\nTO_STD = KC.DF(LYR_STD)\nMT_EXT = KC.MO(LYR_EXT)\nTO_NUM = KC.MO(LYR_NUM)\nTO_GAME = KC.DF(LYR_GAME)\n\n\n# Keymap\n\nkeyboard.keymap = [\n    # Standard (ISO) Layer\n    [\n        KC.ESC , KC.N1  , KC.N2  , KC.N3  , KC.N4  , KC.N5  , KC.N6  , KC.N7  , KC.N8  , KC.N9  , KC.N0  , KC.MINS, KC.EQL , KC.BSPC,\n        KC.TAB , KC.Q   , KC.W   , KC.E   , KC.R   , KC.T   , KC.Y   , KC.U   , KC.I   , KC.O   , KC.P   , KC.LBRC, KC.RBRC, KC.DEL ,\n        xxxxxxx, KC.A   , KC.S   , KC.D   , KC.F   , KC.G   , KC.H   , KC.J   , KC.K   , KC.L   , KC.SCLN, KC.QUOT, KC.NUHS, xxxxxxx,\n        KC.LSFT, KC.NUBS, KC.Z   , KC.X   , KC.C   , KC.V   , KC.B   , KC.N   , KC.M   , KC.COMM, KC.DOT , KC.SLSH, KC.UP  , KC.ENT ,\n        KC.LCTL, KC.LGUI, xxxxxxx, KC.LALT, MT_EXT , xxxxxxx, KC.SPC , xxxxxxx, KC.RALT, TO_NUM , KC.RSFT, KC.LEFT, KC.DOWN, KC.RGHT,\n    ],\n    # Extra Keys Layer\n    [\n        TO_STD , KC.F1  , KC.F2  , KC.F3  , KC.F4  , KC.F5  , KC.F6  , KC.F7  , KC.F8  , KC.F9  , KC.F10 , KC.F11 , KC.F12 , KC.RESET,\n        _______, KC.N1  , KC.N2  , KC.N3  , KC.N4  , KC.N5  , KC.N6  , KC.N7  , KC.N8  , KC.N9  , KC.N0  , KC.MINS, KC.EQL , _______,\n        xxxxxxx, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, xxxxxxx,\n        KC.LSFT, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, KC.PGUP, _______,\n        KC.LCTL, KC.LGUI, xxxxxxx, KC.LALT, MT_EXT , xxxxxxx, _______, xxxxxxx, _______, TO_NUM , _______, KC.HOME, KC.PGDN, KC.END ,\n    ],\n    # NumPad Layer\n    [\n        TO_STD , xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, KC.P7  , KC.P8  , KC.P9  , KC.PSLS, xxxxxxx, xxxxxxx, KC.BSPC,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, KC.P4  , KC.P5  , KC.P6  , KC.PAST, xxxxxxx, xxxxxxx, KC.DEL ,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, KC.LPRN, KC.P1  , KC.P2  , KC.P3  , KC.PPLS, xxxxxxx, xxxxxxx, xxxxxxx,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, KC.RPRN, KC.P0  , KC.PDOT, _______, KC.PMNS, xxxxxxx, xxxxxxx, KC.PENT,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, MT_EXT , xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, TO_NUM , xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx,\n    ],\n    # Gaming Layer\n    [\n        TO_STD , xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, MT_EXT , xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, TO_NUM , xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx,\n    ],\n]\n\n# Rotary Encoder (1 encoder / 1 definition per layer)\nencoder_handler.map = ( ((KC.UP, KC.DOWN, KC.MUTE),), # Standard\n                        ((KC.VOLD, KC.VOLU, KC.MUTE),), # Extra\n                        ((KC.A, KC.Z, KC.N1),), # NumPad not yet properly configured\n                        ((KC.A, KC.Z, KC.N1),), # Gaming not yet properly configured\n                        )\n\nif __name__ == "__main__":\n    keyboard.go()\n')))}s.isMDXComponent=!0}}]);