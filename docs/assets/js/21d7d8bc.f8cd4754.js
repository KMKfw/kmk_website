"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[4869],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>y});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(n),m=r,y=d["".concat(p,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(y,i(i({ref:t},c),{},{components:n})):a.createElement(y,i({ref:t},c))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6532:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const o={},i="Tap Dance",l={unversionedId:"tapdance",id:"tapdance",title:"Tap Dance",description:"Tap dance is a way to allow a single physical key to work as multiple logical",source:"@site/docs/tapdance.md",sourceDirName:".",slug:"/tapdance",permalink:"/docs/tapdance",draft:!1,editUrl:"https://github.com/KMKfw/kmk_firmware/tree/master/docs/tapdance.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Support",permalink:"/docs/support"}},p={},s=[],c={toc:s},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"tap-dance"},"Tap Dance"),(0,r.kt)("p",null,'Tap dance is a way to allow a single physical key to work as multiple logical\nkeys / actions without using layers. With basic tap dance, you can trigger these\n"nested" keys or macros through a series of taps of the physical key within a\ngiven timeout.'),(0,r.kt)("p",null,'The resulting "logical" action works just like any other key - it can be pressed\nand immediately released, or it can be held. For example, let\'s take a key\n',(0,r.kt)("inlineCode",{parentName:"p"},"KC.TD(KC.A, KC.B)"),'. If the tap dance key is tapped and released once quickly,\nthe letter "a" will be sent. If it is tapped and released twice quickly, the\nletter "b" will be sent. If it is tapped once and held, the letter "a" will be\nheld down until the tap dance key is released. If it is tapped and released once\nquickly, then tapped and held (both actions within the timeout window), the\nletter "b" will be held down until the tap dance key is released.'),(0,r.kt)("p",null,"To use this, you may want to define a ",(0,r.kt)("inlineCode",{parentName:"p"},"tap_time")," value in your keyboard\nconfiguration. This is an integer in milliseconds, and defaults to ",(0,r.kt)("inlineCode",{parentName:"p"},"300"),".\nThe timeout is reset after each tap and every tapdance sequence can also define\nan individual ",(0,r.kt)("inlineCode",{parentName:"p"},"tap_time"),"."),(0,r.kt)("p",null,"You'll then want to create a sequence of keys using ",(0,r.kt)("inlineCode",{parentName:"p"},"KC.TD(KC.SOMETHING,\nKC.SOMETHING_ELSE, MAYBE_THIS_IS_A_MACRO, WHATEVER_YO)"),", and place it in your\nkeymap somewhere. The only limits on how many keys can go in the sequence are,\ntheoretically, the amount of RAM your MCU/board has."),(0,r.kt)("p",null,"Tap dance supports all ",(0,r.kt)("inlineCode",{parentName:"p"},"HoldTap")," based keys, like mod tap, layer tap, oneshot...\nit will even honor every option set for those keys.\nIndividual timeouts and prefer hold behavior for every tap in the sequence?\nNot a problem."),(0,r.kt)("p",null,"Here's an example of all this in action:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from kmk.keycodes import KC\nfrom kmk.handlers.sequences import send_string\nfrom kmk.modules.tapdance import TapDance\n\nkeyboard = KMKKeyboard()\n\ntapdance = TapDance()\ntapdance.tap_time = 750\nkeyboard.modules.append(tapdance)\n\nEXAMPLE_TD = KC.TD(\n    # Tap once for "a"\n    KC.A,\n    # Tap twice for "b", or tap and hold for "left control"\n    KC.HT(KC.B, KC.LCTL, prefer_hold=False),\n    # Tap three times to send a raw string via macro\n    send_string(\'macros in a tap dance? I think yes\'),\n    # Tap four times to toggle layer index 1, tap 3 times and hold for 3s to\n    # momentary toggle layer index 1.\n    KC.TT(1, tap_time=3000),\n)\n\n# make the default tap time really short for this tap dance:\nEXAMPLE_TD2 = KC.TD(KC.A, KC.B, tap_time=80)\n\n\nkeyboard.keymap = [[ ...., EXAMPLE_TD, ....], ....]\n')))}u.isMDXComponent=!0}}]);