{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"How to get it","text":"<p>KMK is updated often and sometimes a lot. Obtaining a fresh copy can be done by forking the <code>main</code> branch of this repository, or downloading a snapshot of it.</p> <p>Pre-compiled version of KMK can be acquired by navigating to Actions &gt; Build, there it can be found under artifacts for the latest build.</p>"},{"location":"#documentation-index","title":"Documentation index","text":"<p>Before you look further, you probably want to start with our getting started guide.</p>"},{"location":"#basics","title":"Basics","text":"<ul> <li>Getting Started</li> <li>Bluetooth HID: Connect keyboard to PC or mobile device using BLE</li> <li>Configuring KMK</li> <li>Porting to KMK: Creating a <code>kb.py</code> file for a board</li> <li>Debugging</li> <li>Keycodes: List of all available keycodes</li> <li>Officially supported microcontrollers</li> <li>Support</li> <li>Contributing</li> </ul>"},{"location":"#advanced","title":"Advanced","text":"<ul> <li>Flashing instructions</li> <li>Handwiring: Resources helpful when handwiring a keyboard circuit</li> <li>Keys: Technical explanation of key handling</li> <li>Scanners: Setting up non-default key reading</li> </ul>"},{"location":"#modules","title":"Modules","text":"<ul> <li>Combos: Adds chords and sequences</li> <li>Layers: Adds layer support (Fn key) to allow many more keys to be put on your keyboard</li> <li>HoldTap: Adds support for augmented modifier keys to act as one key when tapped, and modifier when held.</li> <li>Macros: Adds macros.</li> <li>Mouse keys: Adds mouse keycodes</li> <li>Sticky keys: Adds support for sticky keys, alias one shot keys.</li> <li>Power: Power saving features. This is mostly useful when on battery power.</li> <li>SerialACE: [DANGER - see module README] Arbitrary Code Execution over the data serial.</li> <li>Split: Keyboards split in two. Seems ergonomic!</li> <li>TapDance: Different key actions depending on how often it is pressed.</li> <li>Steno: Communicate with stenography software over serial.</li> </ul>"},{"location":"#peripherals","title":"Peripherals","text":"<ul> <li>ADNS9800: Controlling ADNS9800 optical sensor</li> <li>Encoder: Handling rotary encoders</li> <li>Pimoroni trackball: Handling a small I2C trackball made by Pimoroni</li> </ul>"},{"location":"#extensions","title":"Extensions","text":"<ul> <li>International: Adds international keycodes</li> <li>LED: Adds backlight support. This is for monocolor backlight, not RGB</li> <li>LockStatus: Exposes host-side locks like caps or num lock.</li> <li>MediaKeys: Adds support for media keys such as volume</li> <li>RGB: RGB lighting for underglow. Will work on most matrix RGB as will be treated the same as underglow.</li> <li>Status LED: Indicates which layer you are on with an array of single leds.</li> </ul>"},{"location":"Display/","title":"Display","text":"<p>Not enough screen space? Add a display to your keyboard!</p> <p>This documentation concerns the recommended Display extension.</p> <p>Note: Driving a display can bind up a considerable amount of CPU time and RAM. Be aware of the performance degradation that can occur.</p>"},{"location":"Display/#preparation","title":"Preparation","text":"<p>First of all you need to download a few libraries that will make it possible for your display to work. You can get them with the Adafruit CircuitPython Libraries bundle. Make sure you to choose the one that matches your version of CircuitPython.</p> <p>Create a <code>lib</code> directory under the CircuitPython drive and copy the following from the library bundle there: * <code>adafruit_display_text/</code></p> <p>Depending on which kind of display your keyboard has, you may also need a display-specific library. See the below table:</p> Display Type Library to use SSD1306 <code>adafruit_displayio_ssd1306.mpy</code> SH1106 <code>adafruit_displayio_sh1106.mpy</code> Already initialized (e.g. available through <code>board.DISPLAY</code>) None"},{"location":"Display/#configuration","title":"Configuration","text":"<p>Here's how you may initialize the extension. Note that this includes examples of all currently supported display types and you only need the one that corresponds to your display:</p> <pre><code>import board\nimport busio\n\nfrom kmk.extensions.display import Display, TextEntry, ImageEntry\n\n# For SSD1306\nfrom kmk.extensions.display.ssd1306 import SSD1306\n\n# Replace SCL and SDA according to your hardware configuration.\ni2c_bus = busio.I2C(board.GP_SCL, board.GP_SDA)\n\ndriver = SSD1306(\n    # Mandatory:\n    i2c=i2c_bus,\n    # Optional:\n    device_address=0x3C,\n)\n\n# For SH1106\nfrom kmk.extensions.display.sh1106 import SH1106\n\n# Replace SCK and MOSI according to your hardware configuration.\nspi_bus = busio.SPI(board.GP_SCK, board.GP_MOSI)\n\n# Replace command, chip_select, and reset according to your hardware configuration.\ndriver = SH1106(\n    # Mandatory:\n    spi=spi_bus,\n    command=board.GP_DC,\n    chip_select=board.GP_CS,\n    reset=board.GP_RESET,\n)\n\n# For displays initialized by CircuitPython by default\n# IMPORTANT: breaks if a display backend from kmk.extensions.display is also in use\nfrom kmk.extensions.display.builtin import BuiltInDisplay\n\n# Replace display, sleep_command, and wake_command according to your hardware configuration.\ndriver = BuiltInDisplay(\n    # Mandatory:\n    display=board.DISPLAY\n    sleep_command=0xAE\n    wake_command=0xAF\n)\n\n# For all display types\ndisplay = Display(\n    # Mandatory:\n    display=driver,\n    # Optional:\n    width=128, # screen size\n    height=32, # screen size\n    flip = False, # flips your display content\n    flip_left = False, # flips your display content on left side split\n    flip_right = False, # flips your display content on right side split\n    brightness=0.8, # initial screen brightness level\n    brightness_step=0.1, # used for brightness increase/decrease keycodes\n    dim_time=20, # time in seconds to reduce screen brightness\n    dim_target=0.1, # set level for brightness decrease\n    off_time=60, # time in seconds to turn off screen\n    powersave_dim_time=10, # time in seconds to reduce screen brightness\n    powersave_dim_target=0.1, # set level for brightness decrease\n    powersave_off_time=30, # time in seconds to turn off screen\n)\n</code></pre> <p>Also shown are all the options with their default values. Customize them to fit your screen and preferences.</p>"},{"location":"Display/#images","title":"Images","text":"<p>Images have to be monochromatic bitmaps with same resolution as your display and have to be placed in the root of the CircuitPython drive. Placing it in separate a separate directory may cause issues.</p> <pre><code>display.entries = [\n    ImageEntry(image=\"1.bmp\", x=0, y=0),\n]\nkeyboard.extensions.append(display)\n</code></pre> <p>You can also make your images appear only on specific layers,</p> <pre><code>display.entries = [\n    ImageEntry(image=\"1.bmp\", x=0, y=0, layer=0),\n    ImageEntry(image=\"2.bmp\", x=0, y=0, layer=1),\n]\nkeyboard.extensions.append(display)\n</code></pre> <p>and/or side of your split keyboard.</p> <pre><code>display.entries = [\n    ImageEntry(image=\"L1.bmp\", x=0, y=0, side=\"L\"),\n    ImageEntry(image=\"R1.bmp\", x=0, y=0, side=\"R\"),\n]\nkeyboard.extensions.append(display)\n</code></pre>"},{"location":"Display/#text","title":"Text","text":"<p>You're able to freely position your text to place it wherever you want just by changing x and y values.</p> <pre><code>display.entries = [\n    TextEntry(text=\"Layer = 1\", x=0, y=0),\n    TextEntry(text=\"Macros\", x=0, y=12),\n    TextEntry(text=\"Hey there!\", x=0, y=24),\n]\nkeyboard.extensions.append(display)\n</code></pre>"},{"location":"Display/#x-and-y-anchors","title":"X and Y anchors","text":"<p>Anchor points define the \"origin\" or <code>(0, 0)</code> position within a text label. Example: for text in top right corner you need to set its anchor points Top Right and move text to far right position. The values can be set \"T\" for top, \"M\" for middle and \"B\" for bottom on the X axis and \"L\" for left, \"M\" for middle and \"R, for right on the Y axis.</p> <p>For more info about anchors check the Adafruit docs. Notable difference: KMK uses strings (\"T\", \"M\",\"B\" and \"L\", \"M\", \"R\") instead of numbers.</p> <pre><code>display.entries = [\n    TextEntry(text=\"Layer = 1\", x=128, y=0, x_anchor=\"R\", y_anchor=\"T\"), # text in Top Right corner\n    TextEntry(text=\"Macros\", x=128, y=64, x_anchor=\"R\", y_anchor=\"B\"), # text in Bottom Right corner\n    TextEntry(text=\"Hey there!\", x=64, y=32, x_anchor=\"M\", y_anchor=\"M\"), # text in the Middle of screen\n]\nkeyboard.extensions.append(display)\n</code></pre>"},{"location":"Display/#split","title":"Split","text":"<p>Same as with images you can change displaying according to current layer or side of split keyboard.</p> <pre><code>display.entries = [\n    TextEntry(text=\"Longer text that\", x=0, y=0, layer=0),\n    TextEntry(text=\"has been divided\", x=0, y=12, layer=0, side=\"L\"),\n    TextEntry(text=\"for an example\", x=0, y=24, layer=0, side=\"R\"),\n]\nkeyboard.extensions.append(display)\n</code></pre>"},{"location":"Display/#inverting","title":"Inverting","text":"<p>Inverts colors of your text. Comes in handy, for example, as a good layer indicator.</p> <pre><code>display = Display(\n    entries=[\n        TextEntry(text='0 1 2 4', x=0, y=0),\n        TextEntry(text='0', x=0, y=0, inverted=True, layer=0),\n        TextEntry(text='1', x=12, y=0, inverted=True, layer=1),\n        TextEntry(text='2', x=24, y=0, inverted=True, layer=2),\n    ],\n)\n</code></pre>"},{"location":"Display/#example-code","title":"Example Code","text":"<pre><code>import board\nimport busio\nfrom kmk.kmk_keyboard import KMKKeyboard\nfrom kmk.keys import KC\nfrom kmk.scanners import DiodeOrientation\nfrom kmk.modules.layers import Layers\nfrom kmk.extensions.display import Display, SSD1306, TextEntry, ImageEntry\n\nkeyboard = KMKKeyboard()\nlayers = Layers()\nkeyboard.modules.append(layers)\n\ni2c_bus = busio.I2C(board.GP21, board.GP20)\ndisplay_driver = SSD1306(\n    i2c=i2c_bus,\n    # Optional device_addres argument. Default is 0x3C.\n    # device_address=0x3C,\n)\n\ndisplay = Display(\n    display=display_driver,\n    entries=[\n        TextEntry(text='Layer: ', x=0, y=32, y_anchor='B'),\n        TextEntry(text='BASE', x=40, y=32, y_anchor='B', layer=0),\n        TextEntry(text='NUM', x=40, y=32, y_anchor='B', layer=1),\n        TextEntry(text='NAV', x=40, y=32, y_anchor='B', layer=2),\n        TextEntry(text='0 1 2', x=0, y=4),\n        TextEntry(text='0', x=0, y=4, inverted=True, layer=0),\n        TextEntry(text='1', x=12, y=4, inverted=True, layer=1),\n        TextEntry(text='2', x=24, y=4, inverted=True, layer=2),\n    ],\n    # Optional width argument. Default is 128.\n    # width=128,\n    height=64,\n    dim_time=10,\n    dim_target=0.2,\n    off_time=1200,\n    brightness=1,\n)\n\nkeyboard.extensions.append(display)\n</code></pre>"},{"location":"Getting_Started/","title":"Getting Started","text":"<p>Life was like a box of chocolates. You never know what you're gonna get.</p> <p>KMK is a keyboard focused layer that sits on top of CircuitPython. As such, it should work with most boards that support CircuitPython. KMK requires CircuitPython version 7.3 or above. Known working and recommended devices can be found in the list of officially supported microcontrollers</p>"},{"location":"Getting_Started/#tldr-quick-start-guide","title":"TL;DR Quick start guide","text":"<p>To infinity and beyond! 1. Install CircuitPython version 7.3 or higher on your board. With most boards, it should be as easy as drag and dropping the firmware on the drive 2. Get an up to date copy of KMK from the main branch  3. Unzip it and copy the KMK folder and the boot.py file at the root of the USB drive corresponding to your board (often appearing as CIRCUITPY) 4. Create a new code.py or main.py file in the same root directory (same level as boot.py) with the example content hereunder: </p> <p>IMPORTANT: adapt the GP0 / GP1 pins to your specific board !</p> <pre><code>print(\"Starting\")\n\nimport board\n\nfrom kmk.kmk_keyboard import KMKKeyboard\nfrom kmk.keys import KC\nfrom kmk.scanners import DiodeOrientation\n\nkeyboard = KMKKeyboard()\n\nkeyboard.col_pins = (board.GP0,)\nkeyboard.row_pins = (board.GP1,)\nkeyboard.diode_orientation = DiodeOrientation.COL2ROW\n\nkeyboard.keymap = [\n    [KC.A,]\n]\n\nif __name__ == '__main__':\n    keyboard.go()\n</code></pre> <ol> <li>With a wire / paperclip / whatever, connect the pins you selected for col_pin and row_pin together.</li> </ol> <p></p> <ol> <li>If it prints the letter \"a\" (or a \"Q\" or ... depending on your keyboard layout), you're done!</li> </ol>"},{"location":"Getting_Started/#now-that-youre-up-and-running-you-may-want-to-go-further","title":"Now that you're up and running, you may want to go further...","text":"<p>This is your last chance. After this, there is no turning back. You take the blue pill\u2014the story ends, you wake up in your bed and believe whatever you want to believe. You take the red pill\u2014you stay in Wonderland, and I show you how deep the rabbit hole goes. Remember: all I'm offering is the truth. Nothing more.</p>"},{"location":"Getting_Started/#youre-extremely-lucky-and-you-have-a-fully-supported-keyboard","title":"You're extremely lucky and you have a fully supported keyboard","text":"<p>If your keyboard and microcontroller are officially supported, simply visit the page for your files, and dropping them on the root of the \"flash drive\". Those pages can be found in the repositories boards folder. You will need the <code>kb.py</code> and <code>main.py</code>. If you need more detailed instructions on how to customize the configuration settings and key mappings, please refer to the config and keymap documentation.</p>"},{"location":"Getting_Started/#youve-got-another-maybe-diy-board-and-want-to-customize-kmk-for-it","title":"You've got another, maybe DIY, board and want to customize KMK for it","text":"<p>First, be sure to understand how your device work, and particularly its specific matrix configuration. You can have a look at how key matrices work or read the guide provided by the QMK team for handwired keyboards Once you've got the gist of it: - To start customizing your <code>code.py</code>/<code>main.py</code> file, please refer to the config and keymap and keys files respectively, which provide detailed instructions on how to modify the configuration settings and key mappings. - There's a reference of the available keycodes - International extension adds keys for non US layouts and Media Keys adds keys for ... media</p> <p>And to go even further: - Macros are used for sending multiple keystrokes in a single action - Layers can transform the whole way your keyboard is behaving with a single touch - HoldTap allow you to customize the way a key behaves whether it is tapped or hold, and TapDance depending on the number of times it is pressed</p> <p>Want to have fun features such as RGB, split keyboards and more? Check out what builtin modules and extensions can do! You can also get ideas from the various user examples that we provide and dig into our documentation.</p>"},{"location":"Getting_Started/#pre-compiling-kmk-for-faster-boot-times-or-microcontrollers-with-limited-flash","title":"Pre-compiling KMK for faster boot times or microcontrollers with limited flash","text":"<p>There are two options: 1. To compile KMK yourself you'll need to download and install the compatible mpy-cross   for your Operating System. Don't forget to add it to your PATH, test by running <code>mpy-cross</code> from a shell (Powershell, Bash, Fish, etc). Once that's set up, run either <code>make compile</code> (if you have <code>make</code>) or <code>python util/compile.py</code>to generate the <code>.mpy</code> versions of KMK files. Then copy the whole compiled <code>kmk/</code> directory to your keyboard.</p> <p>There are even more compile and copy make targets. Power user can compile KMK and additional libraries, and then load the bytecode and keyboard code onto a keyboard in one go:</p> <pre><code>make compile copy-compiled copy-board MPY_SOURCES='kmk/ lib/' BOARD='boards/someboard' MOUNTPOINT='/media/user/someboard'\n</code></pre> <ol> <li>To download a pre-compiled KMK go to Actions &gt; Build on the KMK GitHub project page,   click on the latest build, and you'll find the download link at the bottom of the page under Artifacts. Unzip the download and place the contents in the <code>kmk/</code> directory on your keyboard.</li> </ol> <p>On certain microcontrollers that will still not be enough of a size reduction to fit all of KMK onto the flash (nice!nano for example). You can remove any optional parts of KMK you aren't using. Start by skipping <code>kmk/extensions</code>, <code>kmk/modules</code>, and <code>kmk/quickpin</code> and adding in only the files under those paths used in your keyboard (i.e. files that are imported in your <code>main.py</code> or <code>kb.py</code>).</p>"},{"location":"Getting_Started/#additional-help-and-support","title":"Additional help and support","text":"<p>Roads? Where we're going we don't need roads.</p> <p>In case you need it, debugging help can be found on the debugging page.</p> <p>For asynchronous support and chatter about KMK, join our Zulip community!</p> <p>If you ask for help in chat or open a bug report, if possible make sure your copy of KMK is up-to-date. In particular, swing by the Zulip chat before opening a GitHub Issue about configuration, documentation, etc. concerns.</p>"},{"location":"Officially_Supported_Microcontrollers/","title":"Officially supported microcontrollers","text":"<p>While most CircuitPython devices are great for hand wired keyboards, most keyboards are designed to accept a Pro Micro. The boards listed below either  are, or can be adapted to that pinout to use common keyboards already on the market.</p>"},{"location":"Officially_Supported_Microcontrollers/#nicenano","title":"nice!nano","text":"<p>Features include - Pro Micro pinout - Both USB HID and Bluetooth support - Can do Bluetooth split keyboards with no wires at all - Has battery support including charging</p> <p>Downsides - $25 USD per microcontroller at most retailers - Not enough space to run KMK without compiling</p>"},{"location":"Officially_Supported_Microcontrollers/#pre-compiling-kmk-for-nicenano-or-any-other-microcontroller-with-limited-flash","title":"Pre-compiling KMK for nice!nano (or any other microcontroller with limited flash)","text":"<p>As the nice!nano has limited flash memory you'll need to use a compiled KMK.</p>"},{"location":"Officially_Supported_Microcontrollers/#itsybitsy-m4-express","title":"ItsyBitsy M4 Express","text":"<p>Features include - Affordable at $15 USD - Can run most features of KMK including RGB</p> <p>Downsides - Needs to be adapted to work with Pro Micro pinout keyboards. You can find a tutorial and files for such an adapter in our GitHub repository under /hardware</p>"},{"location":"Officially_Supported_Microcontrollers/#rp2040","title":"RP2040","text":"<p>Features include - Very affordable - Very powerful for the price</p> <p>Downsides - Little support for keyboard kits</p>"},{"location":"Officially_Supported_Microcontrollers/#adafruit-itsybitsy-nrf52840-express","title":"Adafruit ItsyBitsy nRF52840 Express","text":"<p>Features include - Both USB HID and Bluetooth support - More affordable than the nice!nano at only $18</p> <p>Downsides - Needs to be adapted to work with Pro Micro pinout keyboards. You can find a tutorial and files for such an adapter in our GitHub repository under /hardware - No battery support without addon board like this one by adafruit </p>"},{"location":"Officially_Supported_Microcontrollers/#other-microcontrollers","title":"Other microcontrollers","text":"<p>What you'll need to have at minimum - CircuitPython - 256KB of flash storage - HID over USB and/or Bluetooth.</p> <p>Please keep in mind that KMK relies on CircuitPython's ability to use Bluetooth Low Energy with any given controller.</p>"},{"location":"adns9800/","title":"ADNS9800","text":"<p>Add this module for controlling ADNS9800 optical sensor.</p> <pre><code>from kmk.modules.adns9800 import ADNS9800\nkeyboard.modules.append(ADNS9800(cs=board.GP0, sclk=board.GP2, miso=board.GP4, mosi=board.GP3, invert_y=True))\n</code></pre> <p>Firmware for this sensor has to be obtained separately and placed in <code>kmk/modules/adns9800_firmware.py</code></p> <pre><code>firmware = (\n    b'\\x03'\n    b'\\xa6'\n    ...\n)\n</code></pre>"},{"location":"adns9800/#constructor-parameters","title":"Constructor parameters","text":"<pre><code>ADNS9800(cs=*cs_pin*, sclk=*clock_pin*, miso=*miso_pin*, mosi=*mosi_pin*, invert_x=*False*, invert_y=*False*)\n</code></pre>"},{"location":"ble_hid/","title":"BLE HID","text":"<p>Bluetooth connections help clean up the wire mess!</p>"},{"location":"ble_hid/#circuitpython","title":"CircuitPython","text":"<p>If not running KMKPython, this does require the adafruit_ble library from Adafruit. This can be downloaded from the Adafruit CircuitPython BLE repository. It is part of the Adafruit CircuitPython Bundle. Simply put this in the \"root\" of your CircuitPython device. If unsure, it's the folder with main.py in it, and should be the first folder you see when you open the device.</p>"},{"location":"ble_hid/#enabling-ble","title":"Enabling BLE","text":"<p>To enable BLE hid, change the keyboard.go(). By default, the advertised name will be the name of the \"flash drive\". By default this is CIRCUITPY</p> <pre><code>from kmk.hid import HIDModes\n\nif __name__ == '__main__':\n    keyboard.go(hid_type=HIDModes.BLE)\n</code></pre>"},{"location":"ble_hid/#changing-the-advertise-name","title":"Changing the advertise name","text":"<p>There are two ways to change the advertising name. The first would be to change the name of the drive. The second would be to change the keyboard.go() like this.</p> <pre><code>if __name__ == '__main__':\n    keyboard.go(hid_type=HIDModes.BLE, ble_name='KMKeyboard')\n</code></pre>"},{"location":"boot/","title":"boot.py","text":"<p><code>boot.py</code> lives in the root of your keyboard when mounted as a storage device. There is a more detailed explanation in the CircuitPython Documentation, however there are some common use cases for your keyboard listed on this page.</p>"},{"location":"boot/#kmks-builtin-boot-configurator","title":"KMK's builtin boot configurator","text":"<p>KMK ships with a handy boot configuration function that does all the hard work for you. The interface may change in the future, but there is a safety mechanism in place: if anything goes wrong, it'll boot into a mountable and debuggable configuration.</p>"},{"location":"boot/#signature","title":"Signature","text":"<pre><code>from kmk.bootcfg import bootcfg\n\nbootcfg(\n    # required:\n    sense: [microcontroller.Pin, digitalio.DigitalInOut],\n    # optional:\n    source: Optional[microcontroller.Pin, digitalio.DigitalInOut] = None,\n    autoreload: bool = True,\n    boot_device: int = 0,\n    cdc_console: bool = True,\n    cdc_data: bool = False,\n    consumer_control: bool = True,\n    keyboard: bool = True,\n    midi: bool = True,\n    mouse: bool = True,\n    nkro: bool = False,\n    pan: bool = False,\n    storage: bool = True,\n    usb_id: Optional[tuple[str, str]] = None,\n    **kwargs,\n) -&gt; bool\n</code></pre> <p>All optional parameters are set to reflect common CircuitPython defaults, however they may differ from board specific defaults.</p>"},{"location":"boot/#sense","title":"<code>sense</code>","text":"<p><code>sense</code> accepts either uninitialized <code>Pin</code>s or <code>DigitalInOut</code> instances for maximum flexibility. The boot configuration is only applied if <code>sense</code> reads <code>True</code> or \"high\", and skipped if it reads <code>False</code> or \"low\". If <code>sense</code> is an uninitialized <code>Pin</code>, it'll be configured as pulled-up input; it wont be further configured if it is a <code>DigitalInOut</code>.</p>"},{"location":"boot/#source","title":"<code>source</code>","text":"<p><code>source</code> accepts either uninitialized <code>Pin</code>s or <code>DigitalInOut</code> instances for maximum flexibility. It's the \"source\" of the test voltage to be read by the sense pin. If <code>source</code> is an uninitialized <code>Pin</code>, it'll be configured as a \"low\" output; it wont be further configured if it is a <code>DigitalInOut</code>.</p> <p>Common matrix and direct pin configurations (see also the examples below):</p> diode_orientation sense pin source pin <code>COL2ROW</code> column row <code>ROW2COL</code> row column direct pin direct pin <code>None</code>"},{"location":"boot/#autoreload","title":"<code>autoreload</code>","text":"<p>CircuitPython will automatically reload when any data or meta data is written to the CircuitPython drive. Certain operating systems tend to do that without asking; in that case <code>autoreload</code> can be disabled as a workaround.</p>"},{"location":"boot/#boot_device","title":"<code>boot_device</code>","text":"<p>Boot HID device configuration for <code>usb_hid</code>, see the <code>usb_hid</code> documentation for details.</p>"},{"location":"boot/#cdc_console","title":"<code>cdc_console</code>","text":"<p>This will enable or disable the USB endpoint for the serial console with REPL.</p>"},{"location":"boot/#cdc_data","title":"<code>cdc_data</code>","text":"<p>This will enable or disable the USB endpoint for the data serial.</p>"},{"location":"boot/#consumer_control","title":"<code>consumer_control</code>","text":"<p>Enable the HID endpoint for consumer control reports. Those are extra keys for things like multimedia control and browser shortcuts.</p>"},{"location":"boot/#keyboard","title":"<code>keyboard</code>","text":"<p>Enable the keyboard HID endpoint. Why would you disable that? For a split half that isn't connected to USB and needs extra memory for a massive display maybe?</p>"},{"location":"boot/#midi","title":"<code>midi</code>","text":"<p>It's MIDI over USB. Enabled by default in CircuitPython, but most keyboards don't use it.</p>"},{"location":"boot/#mouse","title":"<code>mouse</code>","text":"<p>Enable the HID endpoint for a pointing device. A pointing device, or mouse, is like a keyboard, but with continuous instead of binary keys... which also go sideways.</p>"},{"location":"boot/#nkro","title":"<code>nkro</code>","text":"<p>Enable n-key rollover support. If the default keyboard is enabled, this option will replace the standard 6-key rollover endpoint with an n-key rollover one. This is technically not a standard HID endpoint, but if you want this, you probably know what you're doing.</p>"},{"location":"boot/#pan","title":"<code>pan</code>","text":"<p>Enable panning, aka horizontal scrolling, for the pointing device, aka mouse, hid endpoint.</p>"},{"location":"boot/#storage","title":"<code>storage</code>","text":"<p>Disable storage if you don't want your computer to go \"there's a new thumb drive I have to mount!\" every time you plug in your keyboard.</p>"},{"location":"boot/#usb_id","title":"<code>usb_id</code>","text":"<p>A recent addition to CircuitPython 8 is the ability to give your keyboard an identity other than \"MCU board manufacturer\" - \"CircuitPython device\".</p>"},{"location":"boot/#return-value","title":"return value","text":"<p><code>bootcfg</code> returns <code>true</code> if boot configuration applied successfully and <code>false</code> if it was skipped, in case you want to use the sense pin mechanism for other custom boot configurations. Any unexpected errors are intentionally not handled, in order to be recorded to the <code>boot_out.txt</code> file for easier debugging.</p>"},{"location":"boot/#example-1","title":"Example 1","text":"<ul> <li>diode direction from columns to rows,</li> <li>disabled storage</li> <li>disabled midi</li> <li>disabled mouse</li> <li>custom vendor and device names</li> </ul> <pre><code>import board\n\nfrom kmk.bootcfg import bootcfg\n\nbootcfg(\n    sense=board.GP0,  # column\n    source=board.GP8, # row\n    midi=False,\n    mouse=False,\n    storage=False,\n    usb_id=('KMK Keyboards', 'Custom 60% Ergo'),\n)\n\n</code></pre> <p>Tip: for a diode direction from rows to columns, switch row and column GPIOs when assigning them to sense and source.</p>"},{"location":"boot/#example-2","title":"Example 2","text":"<p>Dedicated switch to disable boot configuration, connected to ground:</p> <pre><code>import board\n\nfrom kmk.bootcfg import bootcfg\n\nbootcfg(sense=board.GP22, ...)\n</code></pre>"},{"location":"boot/#example-3","title":"Example 3","text":"<p>Shut-in mode: Always apply boot configuration and disable any contact to the outside world. Caution: this an example for a <code>DigitalInOut</code> sense pin, and probably an unwise thing to do in actuality.</p> <pre><code>import board\nimport digitalio\n\nfrom kmk.bootcfg import bootcfg\n\nsense = digitalio.DigitalInOut(board.GP42)\nsense.direction = digitalio.Direction.OUTPUT\nsense = True\n\nbootcfg(\n    sense=sense,\n    cdc_console=False,\n    consumer_control=False,\n    keyboard=False,\n    midi=False,\n    mouse=False,\n    storage=False,\n)\n</code></pre> <p>We generally advise against importing your keyboard definition and using rows/columns to define sense and source pins, because that essentially loads the firmware twice, almost doubling boot times.</p>"},{"location":"capsword/","title":"CapsWord","text":"<p>The CapsWord module functions similar to caps lock but will deactivate automatically when its encounters a key that breaks the word or after inactivity timeout. By default it will not deactivate CapsWord on numbers, alphabets, underscore, modifiers, minus, backspace and other keys like HoldTap, Layers, etc. Add it to your keyboard's modules list with:</p> <pre><code>from kmk.modules.capsword import CapsWord\n# default inactivity timeout is 8s\ncaps_word=CapsWord()\n# change inactivity timeout\n# caps_word=CapsWord(timeout=5000) \n# for no inactivity timeout\n# caps_word=CapsWord(timeout=0) \n# add additional ignored keys\n# caps_word.keys_ignored.append(KC.COMMA) \nkeyboard.modules.append(caps_word)\nkeyboard.keymap = [\n    [\n        KC.CW,\n    ],\n]\n</code></pre>"},{"location":"capsword/#keycodes","title":"Keycodes","text":"Key Aliases Description <code>KC.CW</code> <code>KC.CAPSWORD</code> Enables/disables CapsWord"},{"location":"cg_swap/","title":"Ctrl GUI Swap","text":"<p>This module allows to swap Ctrl with GUI and vice versa. This will reset on restart to the default implementation</p>"},{"location":"cg_swap/#enabling-the-module","title":"Enabling the module","text":"<pre><code>from kmk.modules.cg_swap import CgSwap\n# cg_swap disabled on startup\ncg_swap = CgSwap()\n# cg_swap enabled on startup\n# cg_swap = CgSwap(cg_swap_enable=True)\nkeyboard.modules.append(cg_swap)\n\nkeyboard.keymap = [\n    [\n        KC.CG_SWAP, # swap ctrl and gui\n        KC.CG_NORM, # unswap ctrl and gui\n        KC.CG_TOGG, # toggles ctrl and gui swap\n    ],\n]\n</code></pre>"},{"location":"combo_layers/","title":"Combo Layers","text":"<p>Combo Layers is when you hold down 2 or more <code>KC.MO()</code> or <code>KC.LM()</code> keys at a time, and it goes to a defined layer.</p> <p>By default combo layers is not activated. You can activate combo layers by adding this to your <code>main.py</code> file. The <code>combo_layers</code> NEEDS to be above the <code>keyboard.modules.append(Layers(</code>combo_layers<code>))</code></p> <pre><code>combo_layers = {\n  (1, 2): 3,\n   }\nkeyboard.modules.append(Layers(combo_layers))\n</code></pre> <p>In the above code, when layer 1 and 2 are held, layer 3 will activate. If you release 1 or 2 it will go to whatever key is still being held, if both are released it goes to the default (0) layer. You should also notice that if you already have the layers Module activated, you can just add combo layers into <code>(Layers())</code></p> <p>You can add more, and even add more than 2 layers at a time.</p> <pre><code>combo_layers = {\n  (1, 2): 3,\n  (1, 2, 3): 4,\n  }\n</code></pre>"},{"location":"combo_layers/#limitations","title":"Limitations","text":"<p>There can only be one combo layer active at a time and for overlapping matches the first matching combo in <code>combo_layers</code> takes precedence. Example:</p> <pre><code>layers = Layers()\nlayers.combo_layers = {\n  (1, 2, 3): 8,\n  (1, 2): 9,\n  }\nkeyboard.modules.append(Layers(combo_layers))\n</code></pre> <ul> <li>If you activate layers 1 then 2, your active layer will be layer number 9.</li> <li>If you activate layers 1 then 2, then 3, your active layer will be layer   number 3 (because the layer combo <code>(1,2)</code> has been activated, but layer 3   stacks on top).</li> <li>deactivate 1: you're on layer 3</li> <li>deactivate 2: you're on layer 3</li> <li>deactivate 3: you're on layer 8</li> <li>If you activate layers 3 then 1, then 2, your active layer will be layer   number 8. Deactivate layer</li> <li>deactivate any of 1/2/3: you're on layer 0</li> </ul>"},{"location":"combo_layers/#example-code","title":"Example Code","text":"<pre><code>import board\n\nfrom kmk.kmk_keyboard import KMKKeyboard\nfrom kmk.keys import KC\n\ncombo_layers = {\n  (1, 2): 3,\n  }\n\n\nkeyboard = KMKKeyboard()\n\nkeyboard.modules.append(Layers(combo_layers))\n\n\nkeyboard.keymap = [\n    [ #Default\n    KC.A,     KC.B  KC.C  KC.D,\n    KC.E,     KC.F  KC.G  KC.H,\n    KC.MO(1), KC.J, KC.K, KC.MO(2),\n    ],\n    [ #Layer 1\n    KC.N1,    KC.N2, KC.N3, KC.N4,\n    KC.N5,    KC.N6, KC.N7, KC.8,\n    KC.MO(1), KC.N9, KC.N0, KC.MO(2),\n    ],\n        [ #Layer 2\n    KC.EXLM,  KC.AT,   KC.HASH, KC.DLR,\n    KC.PERC,  KC.CIRC, KC.AMPR, KC.ASTR,\n    KC.MO(1), KC.LPRN, KC.RPRN, KC.MO(2),\n    ],\n        [ #Layer 3\n    KC.F1,   KC.F2, KC.F3,  KC.F4,\n    KC.F5,   KC.F6, KC.F7,  KC.F8,\n    KC.MO(1) KC.F9, KC.F10, KC.MO(2)\n    ]\n\n]\n\nif __name__ == '__main__':\n    keyboard.go()\n</code></pre>"},{"location":"combos/","title":"Combos","text":"<p>Combos allow you to assign special functionality to combinations of key presses. The two default behaviors are: * Chords: match keys in random order, all pressed within 50ms. * Sequences: match keys in order, pressed within 1s of one another.</p> <p>You can define combos to listen to any valid KMK key, even internal or functional keys, like HoldTap. When using internal KMK keys, be aware that the order of modules matters.</p> <p>The result of a combo is another key being pressed/released; if the desired action isn't covered by KMK keys: create your own with <code>make_key</code> and attach corresponding handlers.</p> <p>Combos may overlap, i.e. share match keys amongst each other.</p>"},{"location":"combos/#keycodes","title":"Keycodes","text":"New Keycode Description <code>KC.LEADER</code> a dummy / convenience key for leader key sequences"},{"location":"combos/#custom-combo-behavior","title":"Custom Combo Behavior","text":"<p>Optional arguments that customize individual combos: * <code>fast_reset</code>: If True, allows tapping every key (default for sequences);    if False, allows holding at least one key and tapping the rest to repeatedly    activate the combo (default for chords). * <code>per_key_timeout</code>: If True, reset timeout on every key press (default for   sequences). * <code>timeout</code>: Set the time window within which the match has to happen in ms. * <code>match_coord</code>: If True, matches key position in the matrix.</p>"},{"location":"combos/#example-code","title":"Example Code","text":"<pre><code>from kmk.keys import KC, make_key\nfrom kmk.modules.combos import Combos, Chord, Sequence\ncombos = Combos()\nkeyboard.modules.append(combos)\n\nmake_key(\n    names=('MYKEY',),\n    on_press=lambda *args: print('I pressed MYKEY'),\n)\n\ncombos.combos = [\n    Chord((KC.A, KC.B), KC.LSFT),\n    Chord((KC.A, KC.B, KC.C), KC.LALT),\n    Chord((0, 1), KC.ESC, match_coord=True),\n    Chord((8, 9, 10), KC.MO(4), match_coord=True),\n    Sequence((KC.LEADER, KC.A, KC.B), KC.C),\n    Sequence((KC.E, KC.F), KC.MYKEY, timeout=500, per_key_timeout=False, fast_reset=False)\n]\n</code></pre>"},{"location":"config_and_keymap/","title":"Configuring KMK","text":"<p>KMK is configured through a rather large, plain-old-Python class called <code>KMKKeyboard</code>. Subclasses of this configuration exist which pre-fill defaults for various known keyboards (for example, many QMK, TMK, or ZMK keyboards  are supported with a nice!nano, or through our ItsyBitsy to Pro Micro pinout adapter.)  This class is the main interface between end users and the inner workings of KMK.  Let's dive in!</p> <ul> <li>Edit or create a file called <code>main.py</code> on your <code>CIRCUITPY</code> drive. You can also   keep this file on your computer (perhaps under <code>user_keymaps</code> - please feel   free to submit a pull request with your layout definitions!) and copy it over   (either manually or, if you're adept with developer tooling and/or a command   line, our Makefile).</li> </ul> <p>It's definitely recommended to keep a backup of your configuration somewhere   that isn't the microcontroller itself - MCUs die, CircuitPython may run into   corruption bugs, or you might just have bad luck and delete the wrong file   some day.</p> <ul> <li> <p>Assign a <code>KMKKeyboard</code> instance to a variable (ex. <code>keyboard = KMKKeyboard()</code> - note   the parentheses).</p> </li> <li> <p>Make sure this <code>KMKKeyboard</code> instance is actually run at the end of the file with   a block such as the following:</p> </li> </ul> <pre><code>if __name__ == '__main__':\n    keyboard.go()\n</code></pre> <ul> <li>Assign pins and your diode orientation (only necessary on handwire keyboards),   for example:</li> </ul> <pre><code>import board\n\nfrom kmk.scanners import DiodeOrientation\n\ncol_pins = (board.SCK, board.MOSI, board.MISO, board.RX, board.TX, board.D4)\nrow_pins = (board.D10, board.D11, board.D12, board.D13, board.D9, board.D6, board.D5, board.SCL)\nrollover_cols_every_rows = 4\ndiode_orientation = DiodeOrientation.COL2ROW\n</code></pre> <p>The pins should be based on whatever CircuitPython calls pins on your particular board. You can find these in the REPL on your CircuitPython device:</p> <pre><code>import board\nprint(dir(board))\n</code></pre> <p>Note: <code>rollover_cols_every_rows</code> is only supported with <code>DiodeOrientation.COLUMNS</code>/<code>DiodeOrientation.COL2ROW</code>, not <code>DiodeOrientation.ROWS</code>/<code>DiodeOrientation.ROW2COL</code>. It is used for boards such as the Planck Rev6 which reuse column pins to simulate a 4x12 matrix in the form of an 8x6 matrix</p> <ul> <li> <p>Import the global list of key definitions with <code>from kmk.keys import KC</code>. You   can either print this out in the REPL as we did with <code>board</code> above, or simply   look at our Key documentation.   We've tried to keep that listing reasonably up to date, but if it feels like   something is missing, you may need to read through <code>kmk/keys.py</code> (and then   open a ticket to tell us our docs are out of date, or open a PR and fix the   docs yourself!)</p> </li> <li> <p>Define a keymap, which is, in Python terms, a List of Lists of <code>Key</code> objects.   A very simple keymap, for a keyboard with just two physical keys on a single   layer, may look like this:</p> </li> </ul> <pre><code>keyboard.keymap = [[KC.A, KC.B]]\n</code></pre> <ul> <li>The keymap contains a flat list of <code>Key</code> objects for each layer of the keyboard.   The list of keys in each layer are stored as a single list that follows the    grid of row and column pins in the keyboard matrix.  This list starts with keys    in the first row from left to right, then the second row, and so on.   The row x column matrix structure doesn't appear explicitly   in the keymap.  Use <code>KC.NO</code> to mark grid positions without a physical key.   For very sparse grids <code>keyboard.coord_mapping</code> can be useful to avoid <code>KC.NO</code>. </li> </ul> <p>You can further define a bunch of other stuff:</p> <ul> <li> <p><code>keyboard.debug_enabled</code> which will spew a ton of debugging information to the serial   console. This is very rarely needed, but can provide very valuable information   if you need to open an issue.</p> </li> <li> <p><code>keyboard.tap_time</code> which defines how long <code>KC.TT</code> and <code>KC.LT</code> will wait before   considering a key \"held\" (see <code>layers.md</code>).</p> </li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>KMK is a community effort and welcomes contributions of code and documentation from people  of all backgrounds and levels of technical skill. As such, these guidelines should serve  to make contributing as easy as possible for everyone while maintaining a consistent style.</p>"},{"location":"contributing/#contributing-code","title":"Contributing Code","text":"<p>The following guidelines should ensure that any code contributed can be merged in as  painlessly as possible. If you're unsure how to set up your development environment,  feel free to join our Zulip community.</p>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>KMK uses Black with a Python 3.11 target and, (controversially?) single quotes. Further code styling is enforced with isort and flake8 with several plugins.</p> <p>NOTE: before committing code, run <code>make fix-isort fix-formatting test</code> to  reduce workload for the project's maintainers and prevent the CI pipeline from  failing.</p> <p>There are some limited exceptions to the code formatting rules, which can be  found in <code>setup.cfg</code>, notably around <code>user_keymaps</code> (which are also not subject  to Black formatting as documented in <code>pyproject.toml</code>)</p>"},{"location":"contributing/#tests","title":"Tests","text":"<p>Unit tests within the <code>tests</code> folder mock various CircuitPython modules to allow them to be executed in a desktop development environment.</p> <p>Execute tests using the command <code>make unit-tests</code>. The unit-tests target accepts an optional environment variable for specifying a subset of tests with python's <code>unittest</code> syntax:</p> <pre><code>make unit-tests TESTS=\"tests.test_capsword tests.test_hold_tap\"\n</code></pre>"},{"location":"contributing/#contributing-documentation","title":"Contributing Documentation","text":"<p>While KMK welcomes documentation from anyone with and understanding of the issues  and a willingness to write them up, it's a good idea to familiarize yourself with  the docs. Documentation should be informative but concise.</p>"},{"location":"contributing/#styling","title":"Styling","text":"<p>Docs are written and rendered in GitHub Markdown. Check out this comprehensive guide to basic writing and formatting syntax from GitHub's documentation.</p> <p>In particular, KMK's docs should include a title, demarcated with <code>#</code>, and subheadings  should be demarcated with <code>##</code>, <code>###</code>, and so on. Headings should be short and specific.</p>"},{"location":"contributing/#example-code","title":"Example Code","text":"<p>Where possible, practical code examples should be included in documentation to help  new users understand how to implement features. In general, it's better to have a code- block with comments inside it rather than multiple blocks of code broken up with  explanation.</p> <p>Code blocks should be formatted as Python code as follows:</p> <pre><code>```python\nprint('Hello, world!')\n```\n</code></pre> <p>Inline code, indicated with <code>`backticks`</code>, should be used when calling out specific  functions or Python keywords within the body of paragraphs or in lists.</p>"},{"location":"contributing/#license-copyright-and-legal","title":"License, Copyright, and Legal","text":"<p>All software in this repository is licensed under the GNU Public License, version 3. All documentation and hardware designs are licensed under the Creative Commons Attribution-ShareAlike 4.0 license. Contributions to this repository must use these licenses unless otherwise agreed to by the Core team.</p> <p>Due to ethical and legal concerns, any works derived from GitHub Copilot or similar artificial intelligence tooling are unacceptable for inclusion in any first-party KMK repository or other code collection. We further recommend not using GitHub Copilot while developing anything KMK-related, regardless of intent to submit upstream.</p>"},{"location":"debugging/","title":"Debugging","text":"<p>KMK's debug output is written to CircuitPython's serial console -- the one that's used for the REPL -- and is automatically enabled if it detects a connection to that console. It can also be enabled manually, though that shouldn't be necessary in general:</p> <pre><code>keyboard.debug_enabled = True\n</code></pre> <p>Follow for example Adafruit's beginners guide on how to connect to the serial console. For Linux users, we recommend picocom or screen</p>"},{"location":"dynamic_sequences/","title":"Dynamic Sequences","text":"<p>Dynamic sequences allow you to record a sequence just by typing it without modifying your keymap.  Any sequence recorded this way is temporary and  will remain available until your keyboard reboots.</p>"},{"location":"dynamic_sequences/#how-to-use","title":"How to use","text":""},{"location":"dynamic_sequences/#recording","title":"Recording","text":"<ol> <li>Press record</li> <li>Type your sequence</li> <li>Press stop</li> </ol>"},{"location":"dynamic_sequences/#playing","title":"Playing","text":"<ol> <li>Press play to use your recorded sequence</li> </ol>"},{"location":"dynamic_sequences/#enable-dynamic-sequences","title":"Enable dynamic sequences","text":"<pre><code>from kmk.modules.dynamic_sequences import DynamicSequences\n\nkeyboard.modules.append(DynamicSequences())\n</code></pre>"},{"location":"dynamic_sequences/#keycodes","title":"Keycodes","text":"Key Description <code>KC.RECORD_SEQUENCE()</code> Start recording into the current slot <code>KC.PLAY_SEQUENCE()</code> Play the sequence in the current slot <code>KC.STOP_SEQUENCE()</code> Stop recording, playing, or configuring <code>KC.SET_SEQUENCE(x)</code> Change to the sequence in slot <code>x</code> <code>KC.SET_SEQUENCE_REPETITIONS()</code> Change to repetition config mode <code>KC.SET_SEQUENCE_INTERVAL()</code> Change to interval config mode"},{"location":"dynamic_sequences/#config","title":"Config","text":"<pre><code>dynamicSequences = DynamicSequences(\n    slots=1, # The number of sequence slots to use\n    timeout=60000,  # Maximum time to spend in record or config mode before stopping automatically, milliseconds\n    key_interval=0,  # Milliseconds between key events while playing\n    use_recorded_speed=False  # Whether to play the sequence at the speed it was typed\n)\n</code></pre>"},{"location":"dynamic_sequences/#sequence-slots","title":"Sequence slots","text":"<p>You can configure multiple slots that each store a different sequence.  You can change to a specific slot with <code>KC.SET_SEQUENCE(x)</code>, where <code>x</code> is the sequence slot number (starting from <code>0</code>).  Every keycode can take an optional number to change to a specific sequence slot before performing the action.  For example <code>KC.PLAY_SEQUENCE(2)</code> will play the sequence in slot <code>2</code>.  If a slot is not specified, the current slot will be used.</p>"},{"location":"dynamic_sequences/#repeating-sequences","title":"Repeating sequences","text":"<p>Sequences can be set to repeat automatically.  The number of repetitions and the interval between repetitions can be set using <code>KC.SET_SEQUENCE_REPETITIONS()</code> and <code>KC.SET_SEQUENCE_INTERVAL()</code>.  Using one of these keys will put the keyboard in sequence config mode.  In this mode, keypresses will not be sent to the OS and you can use your number keys to type the number of repetitions or the interval time in seconds.  This mode ends when you press <code>KC.ENTER</code>, <code>KC.STOP_SEQUENCE()</code>, or automatically when the timeout is reached.  Repeat settings are stored in the current slot.</p>"},{"location":"easypoint/","title":"AS5013 (aka 'EasyPoint')","text":"<p>Module handles the AM5013 Two-dimensional magnetic position sensor with digital coordinates output</p>"},{"location":"easypoint/#usage","title":"Usage","text":"<p>Declare I2C bus and add this module in your main class.</p> <pre><code>from kmk.modules.easypoint import Easypoint\nimport busio\n\ni2c = busio.I2C(scl=board.GP1, sda=board.GP0)\n\neasypoint = Easypoint(i2c, address=0x40)\nkeyboard.modules.append(easypoint)\n</code></pre> <p>Further configuring the AS5013 involved x/y-offset, and deadzone.</p> <pre><code>easypoint = Easypoint(i2c, address=0x40, y_offset=Y_OFFSET, x_offset=X_OFFSET, dead_x=DEAD_X, dead_y=DEAD_Y)\n</code></pre>"},{"location":"encoder/","title":"Encoder module","text":"<p>Add twist control to your keyboard! Volume, zoom, anything you want.</p> <p>I2C encoder type has been tested with the Adafruit I2C QT Rotary Encoder with NeoPixel.</p> <p>Note: If you have a split keyboard and encoders on both sides should work, it's currently necessary to use the encoder-scanner explained at the bottom of scanners docs.</p>"},{"location":"encoder/#enabling-the-extension","title":"Enabling the extension","text":"<p>The constructor(<code>EncoderHandler</code> class) takes a list of encoders, each one defined as either:</p> <ul> <li>a list of <code>pad_a</code> pin, <code>pad_b</code> pin, <code>button_pin</code> and optionally a flag set to <code>True</code> if you want encoder direction to be reversed;</li> <li>a <code>busio.I2C</code>, address and optionally a flag set to <code>True</code> if you want it to be reversed.</li> </ul> <p>The <code>encoder_map</code> is modeled after the keymap and works the same way. It should have as many layers (key pressed on \"turned left\", key pressed on \"turned right\", key pressed on \"knob pressed\") as your keymap, and use <code>KC.NO</code> keys for layers that you don't require any action. The encoder supports a velocity mode if you desire to make something for video or sound editing. </p>"},{"location":"encoder/#how-to-use","title":"How to use","text":"<p>Here is all you need to use this module in your <code>main.py</code> / <code>code.py</code> file.</p> <ol> <li>Load the module: import encoder handler and add it to keyboard modules.</li> </ol> <pre><code>from kmk.modules.encoder import EncoderHandler\nencoder_handler = EncoderHandler()\nkeyboard.modules = [layers, holdtap, encoder_handler]\n</code></pre> <ol> <li>Define the pins for each encoder: <code>pin_a</code>, <code>pin_b</code> for rotations, <code>pin_button</code> for the switch in the encoder. Set switch to <code>None</code> if the encoder's button is handled differently (as a part of matrix for example) or not at all. If you want to invert the direction of the encoder, set the 4th (optional) parameter <code>is_inverted</code> to <code>True</code>. 5th parameter is encoder divisor (optional), it can be either <code>2</code> or <code>4</code>. If your encoder button pull direction is not the default of <code>digitalio.Pull.UP</code>, you may specify the 6th (optional) parameter <code>button_pull</code> as <code>digitalio.Pull.DOWN</code>.</li> </ol> <pre><code># Regular GPIO Encoder\nencoder_handler.pins = (\n    # regular direction encoder and a button\n    (board.GP17, board.GP15, board.GP14,), # encoder #1 \n    # reversed direction encoder with no button handling and divisor of 2\n    (board.GP3, board.GP5, None, True, 2,), # encoder #2\n    )\n</code></pre> <p>Or in case you have an I2C encoder on a special PCB (e.g. Adafruit I2C QT Rotary Encoder), define I2C encoder as following.</p> <pre><code># I2C Encoder\n\n# Setup i2c\nSDA = board.GP0\nSCL = board.GP1\ni2c = busio.I2C(SCL, SDA)\n\nencoder_handler.pins = ((i2c, 0x36, False), (encoder 2 definition), etc. )\n</code></pre> <ol> <li>Define the mapping of keys to be called for each layer.</li> </ol> <pre><code># You can optionally predefine combo keys as for your layout\nZoom_in = KC.LCTRL(KC.EQUAL)\nZoom_out = KC.LCTRL(KC.MINUS)\n\nencoder_handler.map = [ (( KC.VOLD, KC.VOLU, KC.MUTE), (encoder 2 definition), etc. ), # Layer 1\n                        ((Zoom_out, Zoom_in, KC.NO), (encoder 2 definition), etc. ), # Layer 2\n                        ((KC.A, KC.Z, KC.N1), (encoder 2 definition), etc. ), # Layer 3\n                        ((KC.NO, KC.NO, KC.NO), (encoder 2 definition), etc. ), # Layer 4\n                      ]\n</code></pre>"},{"location":"encoder/#encoder-divisor","title":"Encoder divisor","text":"<p>Depending on your encoder resolution, it may send 4 or 2 pulses (state changes) on every detent. This number is controlled by the <code>divisor</code> property. By default the divisor is set to 4, but if your encoder only activates on every second detent (skips pulses), set the divisor to 2. If the encoder activates twice on every detent, set the value to 4.</p> <p>You can change the default globally for all encoders before initializing the encoder pins (<code>main.py</code> file):</p> <pre><code>encoder_handler.divisor = 2\nencoder_handler.pins = ( (board.GP14, board.GP15, None), (board.GP26, board.GP27, None), )\n</code></pre> <p>Or if you have different types of encoders, set divisor for each encoder individually:</p> <pre><code>encoder_handler.pins = (\n    (board.GP14, board.GP15, None, False, 4), \n    (board.GP26, board.GP27, None, False, 2),\n    (board.GP26, board.GP27, None ), # will be set to global default\n)\n</code></pre> <p>This setting is equivalent to <code>divisor</code> in the <code>rotaryio</code> module. The divisor of <code>1</code> for smooth encoders is not currently supported but you can use the divisor of <code>2</code> for them without issues and any noticeable difference. </p>"},{"location":"encoder/#handler-methods-overrides","title":"Handler methods overrides","text":"<p>Encoder methods <code>on_move_do</code> and <code>on_button_do</code> can be overridden for complex use cases.</p>"},{"location":"encoder/#connecting-the-encoder","title":"Connecting the encoder","text":"<p>Most EC11, EC12 and similar encoders have a common pinout shown below. For EVQWGD001 horizontal roller encoder, the pins are ordered <code>Pin A</code>, <code>Pin B</code>, <code>Ground</code>, and the fourth (furthest from the two switch pins) is not connected. This information is provided just for reference \u2014 always refer to the manufacturer datasheet for the correct pinout.</p> <pre><code>            +----------+                \n Pin A  ----|          |                \n            |          |----- Ground    \n Ground ----|          |                \n            |          |----- Switch Pin\n Pin B  ----|          |                \n            +----------+                \n</code></pre> <p>In this configuration the encoder push button has its own dedicated pin. If the button should instead be a part of the matrix, it needs to be wired to Column and Row like other switches instead of ground.</p>"},{"location":"encoder/#full-example-with-1-encoder","title":"Full example (with 1 encoder)","text":"<pre><code>import board\n\nfrom kmk.kmk_keyboard import KMKKeyboard\nfrom kmk.consts import UnicodeMode\nfrom kmk.keys import KC\nfrom kmk.scanners import DiodeOrientation\nfrom kmk.modules.layers import Layers\nfrom kmk.modules.encoder import EncoderHandler\n\n\nkeyboard = KMKKeyboard()\nlayers = Layers()\nencoder_handler = EncoderHandler()\nkeyboard.modules = [layers, encoder_handler]\n\n\nkeyboard.col_pins = (\n    board.GP0, board.GP1, board.GP2, board.GP3, board.GP4, board.GP5,\n    board.GP6, board.GP7, board.GP8, board.GP9, board.GP10, board.GP11,\n    board.GP12, board.GP13,\n)\nkeyboard.row_pins = (board.GP28, board.GP27, board.GP22, board.GP26, board.GP21)\nkeyboard.diode_orientation = DiodeOrientation.COLUMNS\n\n# I2C example\n#import busio\n#SDA = board.GP0\n#SCL = board.GP1\n#i2c = busio.I2C(SCL, SDA)\n#encoder_handler.i2c = ((i2c, 0x36, False),)\n\n# encoder_handler.divisor = 2 # for encoders with more precision\nencoder_handler.pins = ((board.GP17, board.GP15, board.GP14, False),)\n\nkeyboard.tap_time = 250\nkeyboard.debug_enabled = False\n\n\n# Filler keys\n_______ = KC.TRNS\nxxxxxxx = KC.NO\ntbdtbd = KC.A\n\n\n# Layers\nLYR_STD, LYR_EXT, LYR_NUM, LYR_GAME = 0, 1, 2, 3\n\nTO_STD = KC.DF(LYR_STD)\nMT_EXT = KC.MO(LYR_EXT)\nTO_NUM = KC.MO(LYR_NUM)\nTO_GAME = KC.DF(LYR_GAME)\n\n\n# Keymap\n\nkeyboard.keymap = [\n    # Standard (ISO) Layer\n    [\n        KC.ESC , KC.N1  , KC.N2  , KC.N3  , KC.N4  , KC.N5  , KC.N6  , KC.N7  , KC.N8  , KC.N9  , KC.N0  , KC.MINS, KC.EQL , KC.BSPC,\n        KC.TAB , KC.Q   , KC.W   , KC.E   , KC.R   , KC.T   , KC.Y   , KC.U   , KC.I   , KC.O   , KC.P   , KC.LBRC, KC.RBRC, KC.DEL ,\n        xxxxxxx, KC.A   , KC.S   , KC.D   , KC.F   , KC.G   , KC.H   , KC.J   , KC.K   , KC.L   , KC.SCLN, KC.QUOT, KC.NUHS, xxxxxxx,\n        KC.LSFT, KC.NUBS, KC.Z   , KC.X   , KC.C   , KC.V   , KC.B   , KC.N   , KC.M   , KC.COMM, KC.DOT , KC.SLSH, KC.UP  , KC.ENT ,\n        KC.LCTL, KC.LGUI, xxxxxxx, KC.LALT, MT_EXT , xxxxxxx, KC.SPC , xxxxxxx, KC.RALT, TO_NUM , KC.RSFT, KC.LEFT, KC.DOWN, KC.RGHT,\n    ],\n    # Extra Keys Layer\n    [\n        TO_STD , KC.F1  , KC.F2  , KC.F3  , KC.F4  , KC.F5  , KC.F6  , KC.F7  , KC.F8  , KC.F9  , KC.F10 , KC.F11 , KC.F12 , KC.RESET,\n        _______, KC.N1  , KC.N2  , KC.N3  , KC.N4  , KC.N5  , KC.N6  , KC.N7  , KC.N8  , KC.N9  , KC.N0  , KC.MINS, KC.EQL , _______,\n        xxxxxxx, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, xxxxxxx,\n        KC.LSFT, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, KC.PGUP, _______,\n        KC.LCTL, KC.LGUI, xxxxxxx, KC.LALT, MT_EXT , xxxxxxx, _______, xxxxxxx, _______, TO_NUM , _______, KC.HOME, KC.PGDN, KC.END ,\n    ],\n    # NumPad Layer\n    [\n        TO_STD , xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, KC.P7  , KC.P8  , KC.P9  , KC.PSLS, xxxxxxx, xxxxxxx, KC.BSPC,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, KC.P4  , KC.P5  , KC.P6  , KC.PAST, xxxxxxx, xxxxxxx, KC.DEL ,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, KC.LPRN, KC.P1  , KC.P2  , KC.P3  , KC.PPLS, xxxxxxx, xxxxxxx, xxxxxxx,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, KC.RPRN, KC.P0  , KC.PDOT, _______, KC.PMNS, xxxxxxx, xxxxxxx, KC.PENT,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, MT_EXT , xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, TO_NUM , xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx,\n    ],\n    # Gaming Layer\n    [\n        TO_STD , xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx,\n        xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, MT_EXT , xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx, TO_NUM , xxxxxxx, xxxxxxx, xxxxxxx, xxxxxxx,\n    ],\n]\n\n# Rotary Encoder (1 encoder / 1 definition per layer)\nencoder_handler.map = [ ((KC.UP, KC.DOWN, KC.MUTE),), # Standard\n                        ((KC.VOLD, KC.VOLU, KC.MUTE),), # Extra\n                        ((KC.A, KC.Z, KC.N1),), # NumPad not yet properly configured\n                        ((KC.A, KC.Z, KC.N1),), # Gaming not yet properly configured\n                        ]\n\nif __name__ == \"__main__\":\n    keyboard.go()\n</code></pre>"},{"location":"extension_statusled/","title":"Status LEDs","text":"<p>Indicate which layer you are on with an array of single leds.</p> <p>During startup the leds light up to indicate that the bootup is finished.</p> <p>For the time being just a simple consecutive single led indicator. And when there are more layers than leds it wraps around to the first led again. (Also works for a single led, which just lights when any layer is active)</p> <p>Most of the code comes from the Mono color LED backlight extension.</p>"},{"location":"extension_statusled/#enabling-the-extension","title":"Enabling the extension","text":"<p>To enable the extension you need to define a list of <code>led_pins</code>. It can be a list of a one, two or three pins.</p> <pre><code>from kmk.extensions.statusled import statusLED\nimport board\n\nstatusLED = statusLED(led_pins=[board.GP0, board.GP1, board.GP2])\nkeyboard.extensions.append(statusLED)\n</code></pre>"},{"location":"extension_statusled/#keycodes","title":"[Keycodes]","text":"Key Aliases Description <code>KC.SLED_INC</code> Increase Brightness <code>KC.SLED_DEC</code> Decrease Brightness"},{"location":"extension_statusled/#configuration","title":"Configuration","text":"<p>All of these values can be set by default for when the keyboard boots.</p> <pre><code>statusLED = statusLED(\n    led_pin=led_pin,\n    brightness=30,\n    brightness_step=5,\n    brightness_limit=100,\n    )\n</code></pre> <p>The brightness values are in percentages.</p>"},{"location":"extension_stringy_keymaps/","title":"Stringy Keymaps","text":"<p>Enables referring to keys by <code>'NAME'</code> rather than <code>KC.NAME</code>.\\ This extension allows for a seamless integration of both string-based key references and standard keycodes.</p> <p>For example:</p> <pre><code>from kmk.extensions.stringy_keymaps import StringyKeymaps\n\n# Normal\n# keyboard.keymap = [[ KC.A, KC.B, KC.RESET ]]\n\n# Indexed\n# keyboard.keymap = [[ KC['A'], KC['B'], KC['RESET'] ]]\n\n# String names mixed with normal keycodes\n# keyboard.keymap = [[ 'A' , KC.B, KC.RESET ]]\n\n# String names\nkeyboard.keymap = [[ 'A' , 'B', 'RESET' ]]\n\nstringyKeymaps = StringyKeymaps()\n\n# Enabling debug will show each replacement or failure.\n# This is recommended during the initial development of a keyboard.\n# stringyKeymaps.debug_enable = True\n\nkeyboard.extensions.append(stringyKeymaps)\n</code></pre> <p>It should be noted that these are not ASCII. The string is not what will be sent to the computer. The examples above have no functional difference.</p> <p>When utilizing argumented keys, such as <code>KC.MO(layer)</code>, it's not possible to use a string like <code>'MO(layer)'</code> instead employ the standard notation of e.g. <code>KC.MO(1)</code> in your keymap.</p>"},{"location":"extensions/","title":"Extensions","text":"<p>Extensions add features that change the experience, but not the core features of the keyboard. They are meant to be easy to add, and create your own. These live in a sandbox to help prevent any bad code from crashing your keyboard.</p>"},{"location":"extensions/#core-extensions","title":"Core Extensions","text":"<p>These extensions are provided in all builds and can be enabled. Currently offered extensions are</p> <ul> <li>International: Adds international keycodes</li> <li>LED: Adds backlight support. This is for monocolor backlight, not RGB</li> <li>LockStatus: Exposes host-side locks like caps or num lock.</li> <li>MediaKeys: Adds support for media keys such as volume</li> <li>OLED Displays: Support for common OLED displays.</li> <li>RGB: RGB lighting for underglow. Will work on most matrix RGB as will   be treated the same as underglow.</li> <li>Status LED: Indicates which layer you are on with an array of single leds.</li> <li>Stringy Keymaps: Enables referring to keys by <code>'NAME'</code> rather than <code>KC.NAME</code></li> </ul>"},{"location":"flashing/","title":"Flashing Instructions","text":"<p>In general, we recommend using the instructions in <code>README.md</code>, however, mostly as a development artifact, another method of flashing KMK exists (tested and supported only on Linux, though it should also work on macOS, the BSDs, and other Unix-likes. It may also work on Cygwin and the Windows Subsystem for Linux).</p> <p>Given <code>make</code> and <code>rsync</code> are available on your system (in <code>$PATH</code>), the following will copy the <code>kmk</code> tree to your CircuitPython device, and will copy the file defined as <code>USER_KEYMAP</code> as your <code>main.py</code>. It will also copy our <code>boot.py</code>. If any of these files exist on your CircuitPython device already, they will be overwritten without a prompt.</p> <p>If you get permissions errors here, don't run make as root or with sudo. See <code>Troubleshooting</code> below.</p> <pre><code>make MOUNTPOINT=/media/CIRCUITPY USER_KEYMAP=user_keymaps/nameofyourkeymap.py BOARD=board/nameofyourboard/kb.py\n</code></pre>"},{"location":"flashing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"flashing/#linuxbsd","title":"Linux/BSD","text":"<p>Check to see if your drive may have mounted elsewhere with a GUI tool or other automounter. Most of these tools will mount your device under <code>/media</code>, probably as <code>/media/CIRCUITPY</code>.  If it's not mounted, you can read up on how to mount a drive manually.</p> <p>For example,</p> <p><code>sudo mount -o uid=$(id -u),gid=$(id -g) /dev/disk/by-label/CIRCUITPY ~/mnt</code></p> <p>If you're still having issues, check out our support page to see where you can come say hi and the community will gladly help you out.</p>"},{"location":"handwiring/","title":"Handwire keyboards","text":"<p>This guide will not talk about the physical wiring. Check out our  recommended microcontrollers and  follow this amazing hand wiring guide. That  guide can be followed until you are setting up the firmware. After wiring the  keyboard, you can refer to our porting guide</p>"},{"location":"holdtap/","title":"HoldTap Keycodes","text":"<p>The HoldTap module lets keys do double duty: tap the key to do one thing,  hold it longer than the configurable <code>tap_time</code> to do another.</p> <p>HoldTap is often used with modifier keys. For example <code>KC.HT(KC.ESCAPE, KC.LCTRL)</code> configures  a key that sends Escape when tapped and  left control when held. It can be used with regular keys as well like <code>KC.HT(KC.SPACE, KC.ENTER)</code> to send space on tap and enter on hold.</p> <p>Simply import HoldTap and add it to the modules list. This lets you use <code>KC.HT</code> actions like those below.</p> <pre><code>from kmk.modules.holdtap import HoldTap\nholdtap = HoldTap()\n# optional: set a custom tap timeout in ms\n# holdtap.tap_time = 300\nkeyboard.modules.append(holdtap)\n</code></pre>"},{"location":"holdtap/#keycodes","title":"Keycodes","text":"New Keycode Description <code>LCTL = KC.HT(KC.SOMETHING, KC.LCTRL)</code> <code>LCTRL</code> if held <code>kc</code> if tapped <code>LSFT = KC.HT(KC.SOMETHING, KC.LSFT)</code> <code>LSHIFT</code> if held <code>kc</code> if tapped <code>LALT = KC.HT(KC.SOMETHING, KC.LALT)</code> <code>LALT</code> if held <code>kc</code> if tapped <code>LGUI = KC.HT(KC.SOMETHING, KC.LGUI)</code> <code>LGUI</code> if held <code>kc</code> if tapped <code>RCTL = KC.HT(KC.SOMETHING, KC.RCTRL)</code> <code>RCTRL</code> if held <code>kc</code> if tapped <code>RSFT = KC.HT(KC.SOMETHING, KC.RSFT)</code> <code>RSHIFT</code> if held <code>kc</code> if tapped <code>RALT = KC.HT(KC.SOMETHING, KC.RALT)</code> <code>RALT</code> if held <code>kc</code> if tapped <code>RGUI = KC.HT(KC.SOMETHING, KC.RGUI)</code> <code>RGUI</code> if held <code>kc</code> if tapped <code>SGUI = KC.HT(KC.SOMETHING, KC.LSHFT(KC.LGUI))</code> <code>LSHIFT</code> and <code>LGUI</code> if held <code>kc</code> if tapped <code>LCA = KC.HT(KC.SOMETHING, KC.LCTRL(KC.LALT))</code> <code>LCTRL</code> and <code>LALT</code> if held <code>kc</code> if tapped <code>LCAG = KC.HT(KC.SOMETHING, KC.LCTRL(KC.LALT(KC.LGUI)))</code> <code>LCTRL</code> and <code>LALT</code> and <code>LGUI</code> if held <code>kc</code> if tapped <code>MEH = KC.HT(KC.SOMETHING, KC.LCTRL(KC.LSFT(KC.LALT)))</code> <code>CTRL</code> and <code>LSHIFT</code> and <code>LALT</code> if held <code>kc</code> if tapped <code>HYPR = KC.HT(KC.SOMETHING, KC.HYPR)</code> <code>LCTRL</code> and <code>LSHIFT</code> and <code>LALT</code> and <code>LGUI</code> if held <code>kc</code> if tapped"},{"location":"holdtap/#custom-holdtap-behavior","title":"Custom HoldTap Behavior","text":"<p>The full HoldTap signature is as follows:</p> <pre><code>KC.HT(KC.TAP, KC.HOLD, prefer_hold=True, tap_interrupted=False, tap_time=None, repeat=HoldTapRepeat.NONE)\n</code></pre> <ul> <li><code>prefer_hold</code>: decides which keycode the HoldTap key resolves to when another   key is pressed before the timeout finishes. When <code>True</code> the hold keycode is   chosen, the tap keycode when <code>False</code>.</li> <li><code>tap_interrupted</code>: decides if the timeout will interrupt at the first other   key press/down, or after the first other key up/release. Set to <code>True</code> for   interrupt on release.</li> <li><code>tap_time</code>: length of the tap timeout in milliseconds.</li> <li><code>repeat</code>: decides how to interpret repeated presses if they happen within   <code>tap_time</code> after a release.</li> <li><code>TAP</code>: repeat tap action, if previous action was a tap.</li> <li><code>HOLD</code>: repeat hold action, if previous action was a hold.</li> <li><code>ALL</code>: repeat all of the above.</li> <li><code>NONE</code>: no repeat action (default), everything works as expected.   The <code>HoldTapRepeat</code> enum must be imported from <code>kmk.modules.holdtap</code>.</li> </ul> <p>Each of these parameters can be set for every HoldTap key individually.</p>"},{"location":"international/","title":"International Keycodes","text":"<p>International extension adds keys for non US layouts. It can simply be added to  the extensions list.</p> <pre><code>from kmk.extensions.international import International\nkeyboard.extensions.append(International())\n</code></pre>"},{"location":"international/#keycodes","title":"Keycodes","text":"Key Aliases Description <code>KC.NONUS_HASH</code> <code>KC.NUHS</code> Non-US <code>#</code> and <code>~</code> <code>KC.NONUS_BSLASH</code> <code>KC.NUBS</code> Non-US <code>\\</code> and <code>|</code> <code>KC.INT1</code> <code>KC.RO</code> JIS <code>\\</code> and <code>|</code> <code>KC.INT2</code> <code>KC.KANA</code> JIS Katakana/Hiragana <code>KC.INT3</code> <code>KC.JYEN</code> JIS <code>\u00a5</code> <code>KC.INT4</code> <code>KC.HENK</code> JIS Henkan <code>KC.INT5</code> <code>KC.MHEN</code> JIS Muhenkan <code>KC.INT6</code> JIS Numpad <code>,</code> <code>KC.INT7</code> International 7 <code>KC.INT8</code> International 8 <code>KC.INT9</code> International 9 <code>KC.LANG1</code> <code>KC.HAEN</code> Hangul/English <code>KC.LANG2</code> <code>KC.HANJ</code> Hanja <code>KC.LANG3</code> JIS Katakana <code>KC.LANG4</code> JIS Hiragana <code>KC.LANG5</code> JIS Zenkaku/Hankaku <code>KC.LANG6</code> Language 6 <code>KC.LANG7</code> Language 7 <code>KC.LANG8</code> Language 8 <code>KC.LANG9</code> Language 9"},{"location":"keycodes/","title":"Keys Overview","text":""},{"location":"keycodes/#basic-keys","title":"[Basic Keys]","text":"Key Aliases Description <code>KC.NO</code> Ignore this key (NOOP) <code>KC.TRANSPARENT</code> <code>KC.TRNS</code> Use the next lowest non-transparent key <code>KC.A</code> <code>a</code> and <code>A</code> <code>KC.B</code> <code>b</code> and <code>B</code> <code>KC.C</code> <code>c</code> and <code>C</code> <code>KC.D</code> <code>d</code> and <code>D</code> <code>KC.E</code> <code>e</code> and <code>E</code> <code>KC.F</code> <code>f</code> and <code>F</code> <code>KC.G</code> <code>g</code> and <code>G</code> <code>KC.H</code> <code>h</code> and <code>H</code> <code>KC.I</code> <code>i</code> and <code>I</code> <code>KC.J</code> <code>j</code> and <code>J</code> <code>KC.K</code> <code>k</code> and <code>K</code> <code>KC.L</code> <code>l</code> and <code>L</code> <code>KC.M</code> <code>m</code> and <code>M</code> <code>KC.N</code> <code>n</code> and <code>N</code> <code>KC.O</code> <code>o</code> and <code>O</code> <code>KC.P</code> <code>p</code> and <code>P</code> <code>KC.Q</code> <code>q</code> and <code>Q</code> <code>KC.R</code> <code>r</code> and <code>R</code> <code>KC.S</code> <code>s</code> and <code>S</code> <code>KC.T</code> <code>t</code> and <code>T</code> <code>KC.U</code> <code>u</code> and <code>U</code> <code>KC.V</code> <code>v</code> and <code>V</code> <code>KC.W</code> <code>w</code> and <code>W</code> <code>KC.X</code> <code>x</code> and <code>X</code> <code>KC.Y</code> <code>y</code> and <code>Y</code> <code>KC.Z</code> <code>z</code> and <code>Z</code> <code>KC.N1</code> <code>1</code> and <code>!</code> <code>KC.N2</code> <code>2</code> and <code>@</code> <code>KC.N3</code> <code>3</code> and <code>#</code> <code>KC.N4</code> <code>4</code> and <code>$</code> <code>KC.N5</code> <code>5</code> and <code>%</code> <code>KC.N6</code> <code>6</code> and <code>^</code> <code>KC.N7</code> <code>7</code> and <code>&amp;</code> <code>KC.N8</code> <code>8</code> and <code>*</code> <code>KC.N9</code> <code>9</code> and <code>(</code> <code>KC.N0</code> <code>0</code> and <code>)</code> <code>KC.ENTER</code> <code>KC.ENT</code> Return (Enter) <code>KC.ESCAPE</code> <code>KC.ESC</code> Escape <code>KC.BSPACE</code> <code>KC.BSPC</code> Delete (Backspace) <code>KC.TAB</code> Tab <code>KC.SPACE</code> <code>KC.SPC</code> Spacebar <code>KC.MINUS</code> <code>KC.MINS</code> <code>-</code> and <code>_</code> <code>KC.EQUAL</code> <code>KC.EQL</code> <code>=</code> and <code>+</code> <code>KC.LBRACKET</code> <code>KC.LBRC</code> <code>[</code> and <code>{</code> <code>KC.RBRACKET</code> <code>KC.RBRC</code> <code>]</code> and <code>}</code> <code>KC.BSLASH</code> <code>KC.BSLS</code> <code>\\</code> and <code>|</code> <code>KC.SCOLON</code> <code>KC.SCLN</code> <code>;</code> and <code>:</code> <code>KC.QUOTE</code> <code>KC.QUOT</code> <code>'</code> and <code>\"</code> <code>KC.GRAVE</code> <code>KC.GRV</code>, <code>KC.ZKHK</code> <code>`</code> and <code>~</code>, JIS Zenkaku/Hankaku <code>KC.COMMA</code> <code>KC.COMM</code> <code>,</code> and <code>&lt;</code> <code>KC.DOT</code> <code>.</code> and <code>&gt;</code> <code>KC.SLASH</code> <code>KC.SLSH</code> <code>/</code> and <code>?</code> <code>KC.CAPSLOCK</code> <code>KC.CLCK</code>, <code>KC.CAPS</code> Caps Lock <code>KC.F1</code> F1 <code>KC.F2</code> F2 <code>KC.F3</code> F3 <code>KC.F4</code> F4 <code>KC.F5</code> F5 <code>KC.F6</code> F6 <code>KC.F7</code> F7 <code>KC.F8</code> F8 <code>KC.F9</code> F9 <code>KC.F10</code> F10 <code>KC.F11</code> F11 <code>KC.F12</code> F12 <code>KC.PSCREEN</code> <code>KC.PSCR</code> Print Screen <code>KC.SCROLLLOCK</code> <code>KC.SLCK</code> Scroll Lock <code>KC.PAUSE</code> <code>KC.PAUS</code>, <code>KC.BRK</code> Pause <code>KC.INSERT</code> <code>KC.INS</code> Insert <code>KC.HOME</code> Home <code>KC.PGUP</code> Page Up <code>KC.DELETE</code> <code>KC.DEL</code> Forward Delete <code>KC.END</code> End <code>KC.PGDOWN</code> <code>KC.PGDN</code> Page Down <code>KC.RIGHT</code> <code>KC.RGHT</code> Right Arrow <code>KC.LEFT</code> Left Arrow <code>KC.DOWN</code> Down Arrow <code>KC.UP</code> Up Arrow <code>KC.NUMLOCK</code> <code>KC.NLCK</code> Keypad Num Lock and Clear <code>KC.KP_SLASH</code> <code>KC.PSLS</code> Keypad <code>/</code> <code>KC.KP_ASTERISK</code> <code>KC.PAST</code> Keypad <code>*</code> <code>KC.KP_MINUS</code> <code>KC.PMNS</code> Keypad <code>-</code> <code>KC.KP_PLUS</code> <code>KC.PPLS</code> Keypad <code>+</code> <code>KC.KP_ENTER</code> <code>KC.PENT</code> Keypad Enter <code>KC.KP_1</code> <code>KC.P1</code> Keypad <code>1</code> and End <code>KC.KP_2</code> <code>KC.P2</code> Keypad <code>2</code> and Down Arrow <code>KC.KP_3</code> <code>KC.P3</code> Keypad <code>3</code> and Page Down <code>KC.KP_4</code> <code>KC.P4</code> Keypad <code>4</code> and Left Arrow <code>KC.KP_5</code> <code>KC.P5</code> Keypad <code>5</code> <code>KC.KP_6</code> <code>KC.P6</code> Keypad <code>6</code> and Right Arrow <code>KC.KP_7</code> <code>KC.P7</code> Keypad <code>7</code> and Home <code>KC.KP_8</code> <code>KC.P8</code> Keypad <code>8</code> and Up Arrow <code>KC.KP_9</code> <code>KC.P9</code> Keypad <code>9</code> and Page Up <code>KC.KP_0</code> <code>KC.P0</code> Keypad <code>0</code> and Insert <code>KC.KP_DOT</code> <code>KC.PDOT</code> Keypad <code>.</code> and Delete <code>KC.KP_EQUAL</code> <code>KC.PEQL</code> Keypad <code>=</code> <code>KC.F13</code> F13 <code>KC.F14</code> F14 <code>KC.F15</code> F15 <code>KC.F16</code> F16 <code>KC.F17</code> F17 <code>KC.F18</code> F18 <code>KC.F19</code> F19 <code>KC.F20</code> F20 <code>KC.F21</code> F21 <code>KC.F22</code> F22 <code>KC.F23</code> F23 <code>KC.F24</code> F24 <code>KC.LOCKING_CAPS</code> <code>KC.LCAP</code> Locking Caps Lock <code>KC.LOCKING_NUM</code> <code>KC.LNUM</code> Locking Num Lock <code>KC.LOCKING_SCROLL</code> <code>KC.LSCR</code> Locking Scroll Lock <code>KC.KP_COMMA</code> <code>KC.PCMM</code> Keypad <code>,</code> <code>KC.KP_EQUAL_AS400</code> Keypad <code>=</code> on AS/400 keyboards <code>KC.LCTRL</code> <code>KC.LCTL</code> Left Control <code>KC.LSHIFT</code> <code>KC.LSFT</code> Left Shift <code>KC.LALT</code> Left Alt <code>KC.LGUI</code> <code>KC.LCMD</code>, <code>KC.LWIN</code> Left GUI (Windows/Command/Meta key) <code>KC.RCTRL</code> <code>KC.RCTL</code> Right Control <code>KC.RSHIFT</code> <code>KC.RSFT</code> Right Shift <code>KC.RALT</code> Right Alt <code>KC.RGUI</code> <code>KC.RCMD</code>, <code>KC.RWIN</code> Right GUI (Windows/Command/Meta key)"},{"location":"keycodes/#us-ansi-shifted-symbols","title":"[US ANSI Shifted Symbols]","text":"Key Aliases Description <code>KC.TILDE</code> <code>KC.TILD</code> <code>~</code> <code>KC.EXCLAIM</code> <code>KC.EXLM</code> <code>!</code> <code>KC.AT</code> <code>@</code> <code>KC.HASH</code> <code>#</code> <code>KC.DOLLAR</code> <code>KC.DLR</code> <code>$</code> <code>KC.PERCENT</code> <code>KC.PERC</code> <code>%</code> <code>KC.CIRCUMFLEX</code> <code>KC.CIRC</code> <code>^</code> <code>KC.AMPERSAND</code> <code>KC.AMPR</code> <code>&amp;</code> <code>KC.ASTERISK</code> <code>KC.ASTR</code> <code>*</code> <code>KC.LEFT_PAREN</code> <code>KC.LPRN</code> <code>(</code> <code>KC.RIGHT_PAREN</code> <code>KC.RPRN</code> <code>)</code> <code>KC.UNDERSCORE</code> <code>KC.UNDS</code> <code>_</code> <code>KC.PLUS</code> <code>+</code> <code>KC.LEFT_CURLY_BRACE</code> <code>KC.LCBR</code> <code>{</code> <code>KC.RIGHT_CURLY_BRACE</code> <code>KC.RCBR</code> <code>}</code> <code>KC.PIPE</code> <code>|</code> <code>KC.COLON</code> <code>KC.COLN</code> <code>:</code> <code>KC.DOUBLE_QUOTE</code> <code>KC.DQUO</code>, <code>KC.DQT</code> <code>\"</code> <code>KC.LEFT_ANGLE_BRACKET</code> <code>KC.LABK</code> <code>&lt;</code> <code>KC.RIGHT_ANGLE_BRACKET</code> <code>KC.RABK</code> <code>&gt;</code> <code>KC.QUESTION</code> <code>KC.QUES</code> <code>?</code>"},{"location":"keycodes/#international-keys","title":"[International Keys]","text":"Key Aliases Description <code>KC.NONUS_HASH</code> <code>KC.NUHS</code> ISO Left of Return <code>KC.NONUS_BSLASH</code> <code>KC.NUBS</code> ISO Right of LSHIFT <code>KC.APPLICATION</code> <code>KC.APP</code>,<code>KC.SEL</code>,<code>KC.WINMENU</code> Menu Key (Near RCTRL) <code>KC.INT1</code> <code>KC.RO</code> <code>KC.INT2</code> <code>KC.KANA</code> <code>KC.INT3</code> <code>KC.JYEN</code> <code>KC.INT4</code> <code>KC.HENK</code> <code>KC.INT5</code> <code>KC.MHEN</code> <code>KC.INT6</code> <code>KC.INT7</code> <code>KC.INT8</code> <code>KC.INT9</code> <code>KC.LANG1</code> <code>HAEN</code> <code>KC.LANG2</code> <code>HAEJ</code> <code>KC.LANG3</code> <code>KC.LANG4</code> <code>KC.LANG5</code> <code>KC.LANG6</code> <code>KC.LANG7</code> <code>KC.LANG8</code> <code>KC.LANG9</code>"},{"location":"keycodes/#internal-keys","title":"[Internal Keys]","text":"Key Description <code>KC.RESET</code> Restarts the keyboard <code>KC.RELOAD</code>, <code>KC.RLD</code> Reloads the keyboard software, preserving any serial connections <code>KC.DEBUG</code> Toggle <code>debug_enabled</code>, which enables log spew to serial console <code>KC.ANY</code> Any key between <code>A</code> and <code>/</code> <code>KC.GESC</code> Escape when tapped, <code>`</code> when pressed with Shift or GUI <code>KC.BKDL</code> Backspace when tapped, Delete when pressed with GUI"},{"location":"keycodes/#modifiers","title":"[Modifiers]","text":"Key Description <code>KC.HYPR</code> Hold Left Control, Shift, Alt and GUI <code>KC.MEH</code> Hold Left Control, Shift and Alt <code>KC.LCTL(kc)</code> Hold Left Control and press <code>kc</code> <code>KC.LSFT(kc)</code> Hold Left Shift and press <code>kc</code> <code>KC.LALT(kc)</code> Hold Left Alt and press <code>kc</code> <code>KC.LGUI(kc)</code> Hold Left GUI and press <code>kc</code> <code>KC.RCTL(kc)</code> Hold Right Control and press <code>kc</code> <code>KC.RSFT(kc)</code> Hold Right Shift and press <code>kc</code> <code>KC.RALT(kc)</code> Hold Right Alt and press <code>kc</code> <code>KC.RGUI(kc)</code> Hold Right GUI and press <code>kc</code>"},{"location":"keycodes/#bluetooth-keys","title":"[Bluetooth Keys]","text":"Key Aliases Description <code>KC.BT_CLEAR_BONDS</code> <code>KC.BT_CLR</code> Clears all stored bondings <code>KC.BT_NEXT_CONN</code> <code>KC.BT_NXT</code> Selects the next BT connection <code>KC.BT_PREV_CONN</code> <code>KC.BT_PRV</code> Selects the previous BT connection"},{"location":"keycodes/#media-keys","title":"[Media Keys]","text":"<p>See MediaKeys extension.</p>"},{"location":"keys/","title":"Keys","text":"<p>Note: This is not a lookup table of key objects provided by KMK. That listing can be found in <code>keycodes.md</code>. It's probably worth a look at the raw source if you're stumped: <code>kmk/keys.py</code>.</p>"},{"location":"keys/#key-objects","title":"Key Objects","text":"<p>This is a bunch of documentation about how a physical keypress translates to events (and the lifecycle of said events) in KMK. It's somewhat technical, but if you're looking to extend your keyboard's functionality with extra code, you'll need at least some of this technical knowledge.</p> <p>The first few steps in the process aren't all that interesting for most workflows, which is why they're buried deep in KMK: we scan a bunch of GPIO lanes (about as quickly as CircuitPython will let us) to see where, in a matrix of keys, a key has been pressed. The technical details about this process are probably best left to Wikipedia. Then, we scan through the defined keymap, finding the first valid key at this index based on the stack of currently active layers (this logic, if you want to read through the code, is in <code>kmk/kmk_keyboard.py</code>, method <code>_find_key_in_map</code>).</p> <p>The next few steps are the interesting part, but to understand them, we need to understand a bit about what a <code>Key</code> object is (found in <code>kmk/keys.py</code>). <code>Key</code> objects have a few core pieces of information:</p> <ul> <li> <p>Their <code>code</code>, which can be any integer or None. Integers sent through to the   HID stack (and thus the computer, which will translate that integer to   something meaningful - for example, <code>code=4</code> becomes <code>a</code> on a US QWERTY/Dvorak   keyboard).</p> </li> <li> <p>Handlers for \"press\" (sometimes known as \"keydown\") and \"release\" (sometimes   known as \"keyup\") events. KMK provides handlers for standard keyboard   functions and some special override keys (like <code>KC.GESC</code>, which is an enhanced   form of existing ANSI keys) in <code>kmk/handlers/stock.py</code>.</p> </li> <li> <p>A generic <code>meta</code> field, which is most commonly used for \"argumented\" keys -   objects in the <code>KC</code> object which are actually functions that return <code>Key</code>   instances, which often need to access the arguments passed into the \"outer\"   function. Many of these examples are related to layer switching - for example,   <code>KC.MO</code> is implemented as an argumented key - when the user adds <code>KC.MO(1)</code> to   their keymap, the function call returns a <code>Key</code> object with <code>meta</code> set to an   object containing <code>layer</code> and <code>kc</code> properties, for example. There's other uses   for <code>meta</code>, and examples can be found in <code>kmk/types.py</code></p> </li> </ul> <p><code>Key</code> objects can also be chained together by calling them! To create a key which holds Control and Shift simultaneously, we can simply do:</p> <pre><code>CTRLSHFT = KC.LCTL(KC.LSFT)\n\nkeyboard.keymap = [ ... CTRLSHFT ... ]\n</code></pre> <p>When a key is pressed and we've pulled a <code>Key</code> object out of the keymap, the <code>Key</code> is first passed through the module processing pipeline. Modules can do whatever with that <code>Key</code>, but usually keys either pass right through, or are intercepted and emitted again later (think of timing based modules like Combos and Hold-Tap). Finally the assigned press handler will be run (most commonly, this is provided by KMK). On release the <code>Key</code> object lookup is, most of the time, cached and doesn't require searching the keymap again. Then it's the processing pipeline again, followed by the release handler.</p> <p>Custom behavior can either be achieved with custom press and release handlers or with macros.</p>"},{"location":"keys/#the-key-code-dictionary","title":"The Key Code Dictionary","text":"<p>You can also refer to a key by index:</p> <ul> <li><code>KC['A']</code></li> <li><code>KC['NO']</code></li> <li><code>KC['LALT']</code></li> </ul> <p>Or the <code>KC.get</code> function which has an optional default argument, which will be returned if the key is not found (<code>default=None</code> unless otherwise specified):</p> <ul> <li><code>KC.get('A')</code></li> <li><code>KC.get('NO', None)</code></li> <li><code>KC.get('NOT DEFINED', KC.RALT)</code></li> </ul> <p>Key names are case-sensitive. <code>KC['NO']</code> is different from <code>KC['no']</code>. It is recommended that names are normally UPPER_CASE. The exception to this are alpha keys; <code>KC['A']</code> and <code>KC['a']</code> will both return the same, unshifted, key.</p>"},{"location":"kmkpython_vs_circuitpython/","title":"KMKPython","text":"<p>THIS IS OUT OF DATE. DO NOT USE. ONLY FOR REFERENCE.</p>"},{"location":"kmkpython_vs_circuitpython/#firmware-of-choice","title":"Firmware of choice","text":""},{"location":"kmkpython_vs_circuitpython/#kmkpython_1","title":"KMKPython","text":"<p>KMKPython is a fork of CircuitPython, but with libraries for most extensions built in. This saves you from having to get them all and keep them updated  yourself. There may be other features added in the future that are exclusive to  KMKPython. For the nice!nano, this is highly recommended, and used in place of  CircuitPython. Notable differences include - Built in libraries for Bluetooth, RGB, and more - Saves space as builds are optimized for keyboards - Microcontrollers like the nice!nano will be able to access all features out of the box.</p>"},{"location":"kmkpython_vs_circuitpython/#circuitpython","title":"CircuitPython","text":"<p>CircuitPython can be installed by following this guide using the guide for installing CircuitPython.  It's recommended to run the latest stable version that is at least 5.0 or higher. Beta versions may work, but expect limited support.</p>"},{"location":"kmkpython_vs_circuitpython/#notable-differences-include","title":"Notable differences include","text":"<ul> <li>Supports more devices</li> <li>Less built in libraries. If using RGB, Bluetooth, and more, you will have to  add these libraries yourself</li> <li>Some devices such as the nice!nano don't have much free space, so not all   features can be installed at the same time</li> </ul>"},{"location":"layers/","title":"Layers","text":"<p>Layers module adds keys for accessing other layers. It can simply be added to  the extensions list.</p> <pre><code>from kmk.modules.layers import Layers\nkeyboard.modules.append(Layers())\n</code></pre>"},{"location":"layers/#keycodes","title":"Keycodes","text":"Key Description <code>KC.FD(layer)</code> Replaces the top layer <code>KC.DF(layer)</code> Switches the default layer until the next time the keyboard powers off <code>KC.MO(layer)</code> Momentarily activates layer, switches off when you let go <code>KC.LM(layer, mod)</code> As <code>MO(layer)</code> but with <code>mod</code> active <code>KC.LT(layer, kc)</code> Momentarily activates layer if held, sends kc if tapped <code>KC.TG(layer)</code> Toggles the layer (enables it if not active, and vice versa) <code>KC.TO(layer)</code> Activates layer and deactivates all other layers <code>KC.TT(layer)</code> Momentarily activates layer if held, toggles it if tapped repeatedly"},{"location":"layers/#custom-holdtap-behavior","title":"Custom HoldTap Behavior","text":"<p><code>KC.TT</code> and <code>KC.LT</code> use the same heuristic to determine taps and holds as HoldTap. Check out the HoldTap doc to find out more.</p>"},{"location":"layers/#working-with-layers","title":"Working with Layers","text":"<p>When starting out, care should be taken when working with layers, since it's possible to lock  yourself to a layer with no way of returning to the base layer short of unplugging your  keyboard. This is especially easy to do when using the <code>KC.TO()</code> keycode, which deactivates  all other layers in the stack.</p> <p>Some helpful guidelines to keep in mind as you design your layers: - Only reference higher-numbered layers from a given layer - Leave keys as <code>KC.TRNS</code> in higher layers when they would overlap with a layer-switch</p>"},{"location":"layers/#using-combo-layers","title":"Using Combo Layers","text":"<p>Combo Layers allow you to activate a corresponding layer based on the activation of 2 or more other layers. The advantage of using Combo layers is that when you release one of the layer keys, it stays on whatever layer is still being held. See combo layers documentation for more information on it's function and to see examples.</p>"},{"location":"layers/#using-multiple-base-layers","title":"Using Multiple Base Layers","text":"<p>In some cases, you may want to have more than one base layer (for instance you want to use  both QWERTY and Dvorak layouts, or you have a custom gamepad that can switch between  different games). In this case, best practice is to have these layers be the lowest, i.e.  defined first in your keymap. These layers are mutually-exclusive, so treat changing default  layers with <code>KC.DF()</code> the same way that you would treat using <code>KC.TO()</code></p>"},{"location":"layers/#example-code","title":"Example Code","text":"<p>For our example, let's take a simple 3x3 macropad with two layers as follows:</p> <pre><code>from kmk.modules.layers import Layers\nkeyboard.modules.append(Layers())\n\n# Layer Keys\nMOMENTARY = KC.MO(1)\nMOD_LAYER = KC.LM(1, KC.RCTL)\nLAYER_TAP = KC.LT(1, KC.END, prefer_hold=True, tap_interrupted=False, tap_time=250) # any tap longer than 250ms will be interpreted as a hold\n\nkeyboard.keymap = [\n    # Base layer\n    [\n        KC.NO,  KC.UP,  KC.NO,  \n        KC.LEFT,KC.DOWN,KC.RGHT,\n        MOMENTARY, LAYER_TAP, MOD_LAYER,\n    ],\n\n    # Function Layer\n    [\n        KC.F1,  KC.F2,  KC.F3,\n        KC.F4,  KC.F5,  KC.F6,\n        KC.TRNS,KC.TRNS,KC.TRNS,    \n    ],\n]\n</code></pre>"},{"location":"layers/#active-layer-indication-with-rgb","title":"Active Layer indication with RGB","text":"<p>A common question is: \"How do I change RGB background based on my active layer?\" Here is one (simple) way of many to go about it.</p> <p>To indicate active layer you can use RGB background, or in many cases board's status LED, then no additional hardware is needed. Information about the LED type and to which GPIO pin it is connected is often available on the pinout of the board and in the documentation.</p> <p>In this example on board RGB status LED is used. Number of layers is unlimited and only chosen layers can be used. Note, that LED's basic colors can have different order for different hardware.</p> <pre><code>import board\n\nfrom kmk.extensions.rgb import RGB\nfrom kmk.modules.layers import Layers\n\n\nclass LayerRGB(RGB):\n    def on_layer_change(self, layer):\n        if layer == 0:\n            self.set_hsv_fill(0, self.sat_default, self.val_default)   # red\n        elif layer == 1:\n            self.set_hsv_fill(170, self.sat_default, self.val_default) # blue\n        elif layer == 2:\n            self.set_hsv_fill(43, self.sat_default, self.val_default)  # yellow\n        elif layer == 4:\n            self.set_hsv_fill(0, 0, self.val_default)                  # white\n\n\nrgb = LayerRGB(pixel_pin=board.GP16, # GPIO pin of the status LED, or background RGB light\n        num_pixels=1,                # one if status LED, more if background RGB light\n        rgb_order=(0, 1, 2),         # RGB order may differ depending on the hardware\n        hue_default=0,               # in range 0-255: 0/255-red, 85-green, 170-blue\n        sat_default=255,\n        val_default=5,\n        )\nkeyboard.extensions.append(rgb)\n\n\nclass RGBLayers(Layers):\n    def activate_layer(self, keyboard, layer, idx=None):\n        super().activate_layer(keyboard, layer, idx)\n        rgb.on_layer_change(layer)\n\n    def deactivate_layer(self, keyboard, layer):\n        super().deactivate_layer(keyboard, layer)\n        rgb.on_layer_change(keyboard.active_layers[0])\n\n\nkeyboard.modules.append(RGBLayers())\n</code></pre>"},{"location":"led/","title":"LED (Mono color backlight)","text":"<p>Want your keyboard to shine? Add some lights!</p>"},{"location":"led/#enabling-the-extension","title":"Enabling the extension","text":"<p>The only required values that you need to give the LED extension would be the <code>led_pin</code>. It can either be a single board pin, or a list of pins for multiple LED's.</p> <pre><code>from kmk.extensions.LED import LED\nimport board\n\nled = LED(led_pin=[board.GP0, board.GP1])\nkeyboard.extensions.append(led)\n</code></pre>"},{"location":"led/#keycodes","title":"[Keycodes]","text":"Key Aliases Description <code>KC.LED_TOG()</code> Toggles LED's <code>KC.LED_INC()</code> Increase Brightness <code>KC.LED_DEC()</code> Decrease Brightness <code>KC.LED_SET()</code> Set Brightness <code>KC.LED_ANI</code> Increase animation speed <code>KC.LED_AND</code> Decrease animation speed <code>KC.LED_MODE_PLAIN</code> <code>LED_M_P</code> Static LED's <code>KC.LED_MODE_BREATHE</code> <code>LED_M_B</code> Breathing animation <p>Keycodes with arguments can affect all, or a selection of LED's.</p> <pre><code># toggle all LEDs\nLED_TOG_ALL = KC.LED_TOG()\n\n# increase brightness of first LED\nLED_INC_0   = KC.LED_INC(0)\n\n# decrease brightness of second and third LED\nLED_DEC_1_2 = KC.LED_DEC(1,2)\n\n</code></pre>"},{"location":"led/#configuration","title":"Configuration","text":"<p>All of these values can be set by default for when the keyboard boots.</p> <pre><code>from kmk.extensions.led import AnimationModes\nled = LED(\n    led_pin=led_pin,\n    brightness=50,\n    brightness_step=5,\n    brightness_limit=100,\n    breathe_center=1.5,\n    animation_mode=AnimationModes.STATIC,\n    animation_speed=1,\n    user_animation=None,\n    val=100,\n    )\n</code></pre>"},{"location":"lock_status/","title":"Lock Status","text":"<p>This extension exposes host-side locks like caps or num lock.</p>"},{"location":"lock_status/#enabling-the-extension","title":"Enabling the extension","text":"<pre><code>from kmk.extensions.lock_status import LockStatus\n\nlocks = LockStatus()\nkeyboard.extensions.append(locks)\n\n</code></pre>"},{"location":"lock_status/#read-lock-status","title":"Read Lock Status","text":"<p>Lock states can be retrieved with getter methods and are truth valued -- <code>True</code> when the lock is enabled and <code>False</code> otherwise.</p> Method Description <code>locks.get_num_lock()</code> Num Lock <code>locks.get_caps_lock()</code> Caps Lock <code>locks.get_scroll_lock()</code> Scroll Lock <code>locks.get_compose()</code> Compose <code>locks.get_kana()</code> Kana"},{"location":"lock_status/#react-to-lock-status-changes","title":"React to Lock Status Changes","text":"<p>The best way to react to changes in lock status is to extend the LockStatus class. When a lock status change happens, the 'after_hid_send' function is invoked so you would override LockStatus's to inject your own logic. Be aware though that this function is also critically important to the functionality of LockStatus so be sure to invoke the 'super()' version of your class to trigger the default functionality of LockStatus.</p> <pre><code># in your main.py\nfrom kb import KMKKeyboard\nfrom kmk.extensions.lock_status import LockStatus\nfrom kmk.extensions.LED import LED\n\nkeyboard = KMKKeyboard()\nleds = LED(led_pin=[board.GP27, board.GP28])\n\nclass LEDLockStatus(LockStatus):\n    def set_lock_leds(self):\n        if self.get_caps_lock():\n            leds.set_brightness(50, leds=[0])\n        else:\n            leds.set_brightness(0, leds=[0])\n\n        if self.get_scroll_lock():\n            leds.set_brightness(50, leds=[1])\n        else:\n            leds.set_brightness(0, leds=[1])\n\n    def after_hid_send(self, sandbox):\n        super().after_hid_send(sandbox)  # Critically important. Do not forget\n        if self.report_updated:\n            self.set_lock_leds()\n\nkeyboard.extensions.append(leds)\nkeyboard.extensions.append(LEDLockStatus())\n</code></pre>"},{"location":"macros/","title":"Macros","text":"<p>Macros are used for sending multiple keystrokes in a single action, and can be used for things like Unicode characters (even emojis! \ud83c\udde8\ud83c\udde6), Lorem ipsum generators, triggering side effects (think lighting, speakers, microcontroller-optimized cryptocurrency miners, whatever).</p>"},{"location":"macros/#setup","title":"Setup","text":"<pre><code>from kmk.modules.macros import Macros\n\nmacros = Macros()\nkeyboard.modules.append(macros)\n</code></pre> <p>This will enable a new type of keycode: <code>KC.MACRO()</code></p>"},{"location":"macros/#keycodes","title":"Keycodes","text":"Key Description <code>KC.MACRO(macro)</code> Create a key that will play back a macro. <code>KC.UC_MODE_IBUS</code> Switch Unicode mode to IBus. <code>KC.UC_MODE_MACOS</code> Switch Unicode mode to macOS. <code>KC.UC_MODE_WINC</code> Switch Unicode mode to Windows Compose. <p>Full macro signature, all arguments optional:</p> <pre><code>KC.MACRO(\n    on_press=None,\n    on_hold=None,\n    on_release=None,\n    blocking=True,\n)\n</code></pre>"},{"location":"macros/#on_press","title":"<code>on_press</code>","text":"<p>This sequence is run once at the beginning, just after the macro key has been pressed. <code>KC.MACRO(macro)</code> is actually a short-hand for <code>KC.MACRO(on_press=macro)</code>.</p>"},{"location":"macros/#on_hold","title":"<code>on_hold</code>","text":"<p>This sequence is run in a loop while the macro key is pressed (or \"held\"). If the key is released before the <code>on_press</code> sequence is finished, the <code>on_hold</code> sequence will be skipped.</p>"},{"location":"macros/#on_release","title":"<code>on_release</code>","text":"<p>This sequence is run once at the end, after the macro key has been released and the previous sequence has finished.</p>"},{"location":"macros/#blocking","title":"<code>blocking</code>","text":"<p>By default, all key events will be intercepted while a macro is running and replayed after all blocking macros have finished. This is to avoid side effects and can be disabled with <code>blocking=False</code> if undesired. (And yes, technically multiple blocking macros can run simultaneously, the achievement of which is left as an exercise to the reader.)</p>"},{"location":"macros/#sending-strings","title":"Sending strings","text":"<p>The most basic sequence is an ASCII string. It can be used to send any standard English alphabet character, and an assortment of other \"standard\" keyboard keys (return, space, exclamation points, etc.). Keep in mind that some characters from shifted keys are i18n dependent.</p> <pre><code>WOW = KC.MACRO(\"Wow, KMK is awesome!\")\n\nkeyboard.keymap = [&lt;other keycodes&gt;, WOW, &lt;other keycodes&gt;]\n</code></pre>"},{"location":"macros/#key-sequences","title":"Key sequences","text":"<p>If you need to add modifier keys to your sequence or you need more granular control. You can use it to add things like copying/pasting, tabbing between fields, etc.</p> <pre><code>from kmk.modules.macros import Press, Release, Tap\n\nPASTE_WITH_COMMENTARY = KC.MACRO(\n    \"look at this: \",\n    Press(KC.LCTL),\n    Tap(KC.V),\n    Release(KC.LCTL)\n)\n\nkeyboard.keymap = [&lt;other keycodes&gt;, PASTE_WITH_COMMENTARY, &lt;other keycodes&gt;]\n</code></pre> <p>The above example will type out \"look at this: \" and then paste the contents of your clipboard.</p>"},{"location":"macros/#sleeping-within-a-sequence","title":"Sleeping within a sequence","text":"<p>If you need to wait during a sequence, you can use <code>Delay(ms)</code> to wait a length of time, in milliseconds.</p> <pre><code>from kmk.modules.macros import Tap, Delay\n\nCOUNTDOWN_TO_PASTE = KC.MACRO(\n    Tap(KC.N3),\n    Tap(KC.ENTER),\n    Delay(1000),\n    Tap(KC.N2),\n    Tap(KC.ENTER),\n    Delay(1000),\n    Tap(KC.N1),\n    Tap(KC.ENTER),\n    Delay(1000),\n    Tap(KC.LCTL(KC.V)),\n)\n\nkeyboard.keymap = [&lt;other keycodes&gt;, COUNTDOWN_TO_PASTE, &lt;other keycodes&gt;]\n</code></pre> <p>This example will type out the following, waiting one second (1000 ms) between numbers:</p> <pre><code>3\n2\n1\n</code></pre> <p>and then paste the contents of your clipboard.</p>"},{"location":"macros/#alt-tab-with-delay","title":"Alt Tab with delay","text":"<p>If alt tab isn't working because it requires a delay, adding a delay and triggering down and up on ALT manually may fix the issue.</p> <pre><code>from kmk.modules.macros import Delay, Press, Release, Tap\n\nNEXT = KC.MACRO(\n    Press(KC.LALT),\n    Delay(30),\n    Tap(KC.TAB),\n    Delay(30),\n    Release(KC.LALT),\n)\n</code></pre>"},{"location":"macros/#unicode","title":"Unicode","text":""},{"location":"macros/#unicode-modes","title":"Unicode Modes","text":"<p>On Linux, Unicode uses <code>Ctrl-Shift-U</code>, which is supported by <code>ibus</code> and GTK+3. <code>ibus</code> users will need to add <code>IBUS_ENABLE_CTRL_SHIFT_U=1</code> to their environment (<code>~/profile</code>, <code>~/.bashrc</code>, <code>~/.zshrc</code>, or through your desktop environment's configurator).</p> <p>On Windows, WinCompose is required.</p> <ul> <li>Linux : <code>UnicodeModeIBus</code>, the default</li> <li>MacOS: <code>UnicodeModeMacOS</code></li> <li>Windows: <code>UnicodeModeWinC</code></li> </ul>"},{"location":"macros/#unicode-examples","title":"Unicode Examples","text":"<p>Initialize <code>Macros</code> to use <code>UnicodeModeMac</code> and make a key to cycle between modes at runtime.</p> <pre><code>from kmk.keys import Key\nfrom kmk.modules.macros import Macros, UnicodeModeIBus, UnicodeModeMacOS, UnicodeModeWinC\n\nmacros = Macros(unicode_mode=UnicodeModeMacOS)\nkeyboard.modules.append(macros)\n\ndef switch_um(keyboard):\n    if macros.unicode_mode == UnicodeModeIBus:\n        macros.unicode_mode = UnicodeModeMacOS\n    elif macros.unicode_mode == UnicodeModeMacOS:\n        macros.unicode_mode = UnicodeModeWinC\n    else:\n        macros.Unicode_mode = UnicodeModeIBus\n\nUCCYCLE = Key(code=None, on_press=switch_um)\n\nFLIP = KC.MACRO('(\u30ce\u0ca0\u75ca\u0ca0)\u30ce\u5f61\u253b\u2501\u253b')\n\nkeyboard.keymap = [&lt;other keycodes&gt;, UCCYCLE, FLIP, &lt;other keycodes&gt;]\n</code></pre>"},{"location":"macros/#arbitrary-actions","title":"Arbitrary Actions","text":"<p>As it happens, macros accept any callable object (even generators) as arguments. The <code>KMKKeyboard</code> object is passed as argument to that callable.</p>"},{"location":"macros/#example-1","title":"Example 1","text":"<p>Change the RGB animation mode to \"SWIRL\" for five seconds and print an ASCII spinner</p> <pre><code># ... boilerplate omitted for brevity.\n\nprev_animation = None\n\ndef start_spinning(keyboard):\n    global prev_animation\n    prev_animation = rgb.animation_mode\n    rgb.animation_mode = AnimationModes.SWIRL\n    rgb.effect_init = True\n\ndef stop_spinning(keyboard):\n    rgb.animation_mode = prev_animation\n    rgb.effect_init = True\n\nDISCO = KC.MACRO(\n    \"disco time!\",\n    start_color_wheel,\n    \"-\",\n    DELAY(1000),\n    KC.BSPC,\n    \"\\\\\",\n    DELAY(1000),\n    KC.BSPC,\n    \"|\",\n    DELAY(1000),\n    KC.BSPC,\n    \"/\",\n    DELAY(1000),\n    KC.BSPC,\n    \"-\",\n    DELAY(1000),\n    KC.BSPC,\n    stop_color_wheel,\n    \" disco time over.\",\n    )\n</code></pre>"},{"location":"macros/#example-2","title":"Example 2","text":"<p>Here's a programmatic version of the earlier countdown-to-paste example, using a generator. Any return value that is not <code>None</code> is interpreted as a delay instruction in milliseconds.</p> <pre><code>def countdown(count, delay_ms):\n    def generator(keyboard):\n        for n in range(count, 0, -1):\n            KC[n].on_press(keyboard)\n            yield\n            KC[n].on_release(keyboard)\n            yield\n            KC.ENTER.on_press(keyboard)\n            yield\n            KC.ENTER.on_release(keyboard)\n            yield delay_ms\n    return generator\n\nCOUNTDOWN_TO_PASTE = KC.MACRO(\n    countdown(3, 1000),\n    Tap(KC.LCTL(KC.V)),\n)\n</code></pre>"},{"location":"macros/#example-3","title":"Example 3","text":"<p>A high productivity replacement for the common space key: This macro ensures that you make good use of your time by measuring how long you've been holding the space key for, printing the result to the debug console, all the while reminding you that you're still holding the space key.</p> <pre><code>from supervisor import ticks_ms\nfrom kmk.utils import Debug\n\ndebug = Debug(__name__)\n\ndef make_timer():\n    ticks = 0\n    def _():\n        nonlocal ticks\n        return (ticks := ticks_ms() - ticks)\n    return _\n\nspace_timer = make_timer()\n\nSPACETIME = KC.MACRO(\n    on_press=(\n        lambda _: space_timer() and None,\n        Press(KC.SPACE),\n        lambda _: debug('start holding space...'),\n    ),\n    on_hold=(\n        lambda _: debug('..still holding space..'),\n    ),\n    on_release=(\n        Release(KC.SPACE),\n        lambda _: debug('...end holding space after ', space_timer(), 'ms'),\n    ),\n    blocking=False,\n)\n</code></pre>"},{"location":"media_keys/","title":"Media Keys","text":"<p>Media keys extension adds keys for common media control keys. It can simply be added to the extensions list.</p> <pre><code>from kmk.extensions.media_keys import MediaKeys\nkeyboard.extensions.append(MediaKeys())\n</code></pre>"},{"location":"media_keys/#keycodes","title":"Keycodes","text":"Key Aliases Description <code>KC.AUDIO_MUTE</code> <code>KC.MUTE</code> Mute <code>KC.AUDIO_VOL_UP</code> <code>KC.VOLU</code> Volume Up <code>KC.AUDIO_VOL_DOWN</code> <code>KC.VOLD</code> Volume Down <code>KC.BRIGHTNESS_UP</code> <code>KC.BRIU</code> Brightness Up <code>KC.BRIGHTNESS_DOWN</code> <code>KC.BRID</code> Brightness Down <code>KC.MEDIA_NEXT_TRACK</code> <code>KC.MNXT</code> Next Track (Windows) <code>KC.MEDIA_PREV_TRACK</code> <code>KC.MPRV</code> Previous Track (Windows) <code>KC.MEDIA_STOP</code> <code>KC.MSTP</code> Stop Track (Windows) <code>KC.MEDIA_PLAY_PAUSE</code> <code>KC.MPLY</code> Play/Pause Track <code>KC.MEDIA_EJECT</code> <code>KC.EJCT</code> Eject (macOS) <code>KC.MEDIA_FAST_FORWARD</code> <code>KC.MFFD</code> Next Track (macOS) <code>KC.MEDIA_REWIND</code> <code>KC.MRWD</code> Previous Track (macOS)"},{"location":"midi/","title":"MIDI","text":"<p>The MIDI module adds keymap entries for sending MIDI data streams. It will require adding the <code>adafruit_midi</code> library from the Adafruit CircuitPython Bundle to your device's folder. Add it to your keyboard's modules list with:</p> <pre><code>from kmk.modules.midi import MidiKeys\nkeyboard.modules.append(MidiKeys())\n</code></pre>"},{"location":"midi/#keycodes","title":"Keycodes","text":"Key Description <code>KC.MIDI_CC(ctrl, val)</code> Sends a ControlChange message <code>KC.MIDI_NOTE(note, velo)</code> Sends a Note message <code>KC.MIDI_PB(val)</code> Sends a Pitch Wheel message <code>KC.MIDI_PC(program)</code> Sends a Program Change message <code>KC.MIDI_START()</code> Sends a Start message <code>KC.MIDI_STOP()</code> Sends a Stop message"},{"location":"modules/","title":"Modules","text":"<p>Modules, unlike extensions, change how your keyboard works. These are meant to have the ability to alter the core code in any way. Unlike extensions, these are not in a sandbox, and can make massive changes to normal operation.</p>"},{"location":"modules/#core-modules","title":"Core Modules","text":"<p>These modules are provided in all builds and can be enabled. Currently offered modules are</p> <ul> <li>Combos: Adds chords and sequences</li> <li>Layers: Adds layer support (Fn key) to allow many more keys to be put on your keyboard.</li> <li>HoldTap: Adds support for augmented modifier keys to act as one key when tapped, and modifier when held.</li> <li>Macros: Adds macros.</li> <li>Mouse keys: Adds mouse keycodes.</li> <li>Sticky keys: Adds support for sticky keys.</li> <li>Power: Power saving features. This is mostly useful when on battery power.</li> <li>Split: Keyboards split in two. Seems ergonomic!</li> <li>SerialACE: [DANGER - see module README] Arbitrary Code Execution over the data serial.</li> <li>TapDance: Different key actions depending on how often it is pressed.</li> <li>Dynamic Sequences: Records a sequence of keypresses and plays it back.</li> </ul>"},{"location":"modules/#require-libraries","title":"Require Libraries","text":"<p>These modules can be used without specific hardware, but require additional libraries such as the <code>Adafruit CircuitPython Bundle</code>.</p> <ul> <li>MIDI: Adds sending MIDI data in the form of keymap entries.</li> </ul>"},{"location":"modules/#peripherals","title":"Peripherals","text":"<p>These modules are for specific hardware and may require additional libraries to function. - ADNS9800: Controlling ADNS9800 optical sensor. - Encoder: Handling rotary encoders. - Pimoroni trackball: Handling a small I2C trackball made by Pimoroni. - AS5013 aka EasyPoint: Handling a small I2C magnetic position sensor made by AMS.</p>"},{"location":"mouse_keys/","title":"Mouse keys","text":"<p>To enable mouse cursor and/or mouse buttons control from the keyboard add this module to list:</p> <pre><code>from kmk.modules.mouse_keys import MouseKeys\nkeyboard.modules.append(MouseKeys())\n</code></pre>"},{"location":"mouse_keys/#keycodes","title":"Keycodes","text":"Keycode Description <code>KC.MB_LMB</code> Left mouse button <code>KC.MB_RMB</code> Right mouse button <code>KC.MB_MMB</code> Middle mouse button <code>KC.MB_BTN4</code> mouse button 4 <code>KC.MB_BTN5</code> mouse button 5 <code>KC.MW_UP</code> Mouse wheel up <code>KC.MW_DOWN</code>, <code>KC.MW_DN</code> Mouse wheel down <code>KC.MW_LEFT</code>, <code>KC.MW_LT</code> Mouse pan left <code>KC.MW_RIGHT</code>, <code>KC.MW_RT</code> Mouse pan right <code>KC.MS_UP</code> Move mouse cursor up <code>KC.MS_DOWN</code>, <code>KC.MS_DN</code> Move mouse cursor down <code>KC.MS_LEFT</code>, <code>KC.MS_LT</code> Move mouse cursor left <code>KC.MS_RIGHT</code>, <code>KC.MS_RT</code> Move mouse cursor right"},{"location":"mouse_keys/#customizing-movement","title":"Customizing Movement","text":"<p>To change the speed and acceleration of mouse movement use the following code:</p> <pre><code>from kmk.modules.mouse_keys import MouseKeys\n\nmousekeys = MouseKeys(\n    max_speed = 10,\n    acc_interval = 20, # Delta ms to apply acceleration\n    move_step = 1\n)\n\nkeyboard.modules.append(mousekeys)\n</code></pre> <p>Note: Support for panning (mouse wheel left/right) <code>boot.py</code> has to be explicitly enabled in <code>boot.py</code> with the <code>bootcfg</code> module.</p>"},{"location":"oneshot/","title":"OneShot Keycodes","text":"<p>OneShot keys or sticky keys enable you to have keys that keep staying pressed for a certain time or until another key is pressed and released. If the timeout expires or other keys are pressed, and the sticky key wasn't released, it is handled as a regular key hold.</p>"},{"location":"oneshot/#enable-oneshot-keys","title":"Enable OneShot Keys","text":"<pre><code>from kmk.modules.oneshot import OneShot\noneshot = OneShot()\n# optional: set a custom tap timeout in ms (default: 1000ms)\n# oneshot.tap_time = 1500\nkeyboard.modules.append(oneshot)\n</code></pre>"},{"location":"oneshot/#keycodes","title":"Keycodes","text":"Keycode Aliases Description <code>KC.OS(KC.ANY)</code> <code>KC.ONESHOT</code> make a sticky version of <code>KC.ANY</code> <p><code>KC.ONESHOT</code> accepts any valid key code as argument, including modifiers and KMK internal keys like momentary layer shifts.</p>"},{"location":"oneshot/#custom-oneshot-behavior","title":"Custom OneShot Behavior","text":"<p>The full OneShot signature is as follows:</p> <pre><code>KC.OS(\n    KC.TAP, # the sticky keycode\n    tap_time=None # length of the tap timeout in milliseconds\n    )\n</code></pre>"},{"location":"oneshot/#oneshot-modifier-combinations","title":"OneShot Modifier Combinations","text":"<p>The OneShot keys can be chained. In this example if you press <code>OS_LCTL</code> and then <code>OS_LSFT</code> followed by <code>KC.TAB</code>, the output will be <code>ctrl+shift+tab</code>.</p> <pre><code>from kmk.modules.oneshot import OneShot\n\noneshot = OneShot()\nkeyboard.modules.append(oneshot)\n\nOS_LCTL = KC.OS(KC.LCTL, tap_time=None)\nOS_LSFT = KC.OS(KC.LSFT, tap_time=None)\n\nkeyboard.keymap = [[OS_LSFT, OS_LCTL, KC.TAB]]\n</code></pre>"},{"location":"peg_rgb_matrix/","title":"Peg RGB Matrix","text":""},{"location":"peg_rgb_matrix/#what-you-can-and-cannot-do-with-this-extension","title":"What you can and cannot do with this extension:","text":""},{"location":"peg_rgb_matrix/#can-do","title":"Can Do","text":"<ul> <li>Set any key's LED to be any color in a syntax very similar to your keymap</li> <li>Allows specific keys to be set to OFF</li> <li>Allows underglow LEDs to be a different color than per-key LEDs</li> <li>Allows modifier keys to be set to a different color than alpha keys</li> <li>Full split keyboard support</li> <li>Change brightness of LEDs from code or using keycodes</li> </ul>"},{"location":"peg_rgb_matrix/#cannot-do-currently-in-progress","title":"Cannot Do (currently in progress)","text":"<ul> <li>Adjust color at runtime. Currently the extension requires changes to main.py in order to make changes to your LEDs.</li> <li>Animations</li> <li>Change LED color based on current layer</li> </ul>"},{"location":"peg_rgb_matrix/#keycodes","title":"Keycodes","text":"<p>Currently this extension does not support changing LEDs at runtime, as a result there are only three keycodes available to interact with this extension,those are:</p> <ul> <li><code>KC.RGB_TOG</code>. This keycode simply toggles all your LEDs on and off.</li> <li><code>KC.RGB_BRI</code>. This keycode increases the brightness of the LEDs.</li> <li><code>KC.RGB_BRD</code>. This keycode decreases the brightness of the LEDs.</li> </ul>"},{"location":"peg_rgb_matrix/#required-libraries","title":"Required Libraries","text":"<p>The following libraries must be frozen in your CircuitPython distribution or in a 'lib' folder at the root of your drive.</p> <ul> <li>Adafruit_CircuitPython_NeoPixel</li> <li>Download .mpy versions from Adafruit_CircuitPython_Bundle</li> </ul>"},{"location":"peg_rgb_matrix/#required-changes-to-mainpy-and-kbpy","title":"Required Changes to main.py and kb.py","text":"<p>In order to use this extension the user must make changes to both their kb.py and main.py files. Below you will find a more comprehensive list of changes required in order to use this extension.</p>"},{"location":"peg_rgb_matrix/#kbpy","title":"kb.py","text":"<p>It is possible your chosen board may already have these changes made, if not you will need to make these additions:</p> <p>The board's kb.py needs 3 fields:</p> <ul> <li>LED Key Position <code>led_key_pos</code></li> <li>Much like <code>coord_mapping</code> this tells the extension where the LEDs are on your board.</li> <li>Brightness Limit <code>brightness_limit</code></li> <li>Limits your brightness and may be required in order to stabilize performance.</li> <li>Number of LEDs <code>num_pixels</code></li> <li>Used for calculations in order to ensure the LEDs map to the correct keys.</li> </ul>"},{"location":"peg_rgb_matrix/#non-split-example","title":"Non-split Example:","text":"<p>Below shows a simple non-split example for a board containing 48 LEDs total and 38 keys with per-key LEDs.  This means we will have 10 underglow LEDs and 38 per-key LEDs. For our example we will assume (because it is most common) the underglow LEDs are connected before the per-key LEDs. Starting from 0, indexes 0-9 are all underglow, so our <code>led_key_pos</code> array starts at 10, the <code>led_key_pos</code> array always starts with the key in the upper left position on the board. Our example is wired in such a way where the positions layout naturally and each row simply increases by 1 starting at the upper left of the board. Of course if your board's LEDs are laid out different, your <code>led_key_pos</code> will need to match that layout.</p> <p>Underglow LEDs always appear at the end of the <code>led_key_pos</code> array, because the array always starts with per-key LEDs.</p> <pre><code>    led_key_pos=[\n        10,11,12,13,14,15,16,17,18,19,\n        20,21,22,23,24,25,26,27,28,29,\n        30,31,32,33,34,35,36,37,38,39,\n           40,41,42,43,44,45,46,47,\n                 5, 6, 7, 8, 9,\n                 0, 1, 2, 3, 4\n        ]\n    brightness_limit = 1.0\n    num_pixels = 48\n</code></pre>"},{"location":"peg_rgb_matrix/#split-example","title":"Split Example:","text":"<p>Below shows a 58 key split keyboard's <code>led_key_pos</code> array for a board containing 70 LEDs in total. The board has 58 keys, meaning we are left with 12 underglow LEDs total. Since the board is a split and we can assume the LEDs are mirrored, that means each half has 29 per-key LEDs and 6 underglow LEDs.</p> <p>Let's first focus on the left half of the board. In this example the underglow LEDs are again connected first, and this half has 6 underglow LEDs. Starting from position 0 this means 0-5 are underglow LEDs and our per-key lighting starts at 6. Our example board is wired in such a way where the left half's first per-key LED is position in the upper right corner of that half. The LEDs then increment towards the right and follow a 'zigzag' pattern until all are accounted for (6-34).  </p> <p>Examining the other half (the right side) you'll notice the LEDs are connected in a similar way but mirrored. The right half's LEDs start in the upper left position of the board and increment towards the right, and then follow a 'zigzag' pattern until all are accounted for (41-69).</p> <p>Underglow LEDs always appear at the end of the <code>led_key_pos</code> array, because the array always starts with per-key LEDs.</p> <pre><code>    led_key_pos =[\n        11,10,9 ,8 ,7 ,6 ,       41,42,43,44,45,46,\n        12,13,14,15,16,17,       52,51,50,49,48,47,\n        23,22,21,20,19,18,       53,54,55,56,57,58,\n        24,25,26,27,28,29,30, 65,64,63,62,61,60,59,\n                 34,33,32,31, 66,67,68,69,\n                 3 ,4 ,5 ,       40,39,38,\n                 2 ,1 ,0 ,       35,36,37\n                 ]\n    brightness_limit = 1.0\n    num_pixels = 70\n\n</code></pre>"},{"location":"peg_rgb_matrix/#mainpy","title":"main.py","text":"<p>It is possible your chosen board may already have these changes made, if not you will need to make these additions:</p> <pre><code>from kmk.extensions.peg_rgb_matrix import Rgb_matrix,Rgb_matrix_data,Color\n# ... Other code\nrgb = Rgb_matrix(...per key color data)\nkeyboard.extensions.append(rgb)\n</code></pre> <p><code>Rgb_matrix</code> extension requires one argument (<code>Rgb_matrix_data</code>), although additional arguments can be passed, here are all arguments that can be passed to </p> <p><code>Rgb_matrix</code>:</p> <ul> <li>LED Display <code>ledDisplay</code></li> <li>This is our primary and only required field, this takes a <code>Rgb_matrix_data</code> class.<ul> <li><code>Rgb_matrix_data</code> only takes two fields:</li> <li>Keys: an array of colors with a length equal to the number of keys on your keyboard</li> <li>Underglow: an array of colors with a length equal to the number of underglow leds on your keyboard</li> </ul> </li> <li>Split <code>split</code></li> <li>This is an optional boolean and only to be used if the keyboard is a split.</li> <li>Right Side <code>rightSide</code></li> <li>This is optional boolean only to be used if the keyboard is split. This signals that this configuration is targeting the right side (off side).</li> <li>RGB Order <code>rgb_order</code></li> <li>This is optional and only needs to be set if you are not using a WS2812 based LED.</li> <li>Disable Auto Write <code>disable_auto_write</code></li> <li>This is optional and only serves to make all your LEDs turn on at once instead of animate to their on state.</li> </ul>"},{"location":"peg_rgb_matrix/#colors","title":"Colors","text":"<p>Colors are RGB and can be provided in one of two ways. Colors can be defined as an array of three numbers (0-255) or you can use the <code>Color</code> class with its default colors, see example below.</p>"},{"location":"peg_rgb_matrix/#passing-rgb-codes","title":"Passing RGB Codes","text":"<pre><code>Rgb_matrix_data(\n    keys=[[255,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],\"\"\"... rest of colors\"\"\" ],                     \n    underglow=[[0,0,55],[0,0,55],\"\"\"... rest of colors\"\"\" ]\n             )\n</code></pre>"},{"location":"peg_rgb_matrix/#using-color-class","title":"Using <code>Color</code> Class","text":"<pre><code>Rgb_matrix_data(\n    keys=[Color.RED, Color.GREEN, Color.BLUE, Color.WHITE, Color.YELLOW, Color.ORANGE,\"\"\"... rest of colors\"\"\" ],                     \n    underglow=[Color.PURPLE, Color.TEAL, Color.PINK, Color.OFF,\"\"\"... rest of colors\"\"\" ]\n             )\n</code></pre>"},{"location":"peg_rgb_matrix/#full-examples","title":"Full Examples","text":"<pre><code>rgb = Rgb_matrix(ledDisplay=Rgb_matrix_data(\n    keys=[\n    [255,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],                        [55,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],[255,55,55],\n    [255,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],                        [55,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],[255,55,55],\n    [255,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],                        [55,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],[255,55,55],\n    [255,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],[255,55,55],[255,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],[55,55,55],[255,55,55],\n                                     [255,55,55],[55,55,55],[55,55,55],[255,55,55],[255,55,55],[55,55,55],[55,55,55],[255,55,55]],\n\n    underglow=[ \n             [0,0,55],[0,0,55],[0,0,55],[0,0,55],[0,0,55],[0,0,55],[0,0,55],[0,0,55],[0,0,55],[0,0,55],[0,0,55],[0,0,55]]\n             ),\n    split=True,\n    rightSide=True,\n    disable_auto_write=True)\n</code></pre>"},{"location":"peg_rgb_matrix/#bonus","title":"Bonus","text":"<p>Because creating <code>ledDisplay</code> can be time consuming, there is a utility available that will generate a basic framework for you.</p> <pre><code>Rgb_matrix_data.generate_led_map(58,10,Color.WHITE,Color.BLUE)\n</code></pre> <p>Call <code>Rgb_matrix_data.generate_led_map</code> before you do any configuration beyond imports and it will print an <code>Rgb_matrix_data</code> class to your CircuitPython REPL which you can view by using a tool like \"screen\" or \"PUTTY\".</p> <p>Generate LED Map Arguments:</p> <ul> <li>Number of Keys</li> <li>Number of Underglow</li> <li>Key Color</li> <li>Underglow Color</li> </ul> <p>Example Using Above Arguments:</p> <pre><code>Rgb_matrix_data(keys=[[249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249], [249, 249, 249]],\nunderglow=[[0, 0, 255], [0, 0, 255], [0, 0, 255], [0, 0, 255], [0, 0, 255], [0, 0, 255], [0, 0, 255], [0, 0, 255], [0, 0, 255], [0, 0, 255]])\n</code></pre> <p>Connecting to the Serial Console</p>"},{"location":"pimoroni_trackball/","title":"Pimoroni Trackball","text":"<p>Module handles usage of Trackball Breakout by Pimoroni.</p>"},{"location":"pimoroni_trackball/#usage","title":"Usage","text":"<p>Declare I2C bus and add this module in your main class.</p> <pre><code>from kmk.modules.pimoroni_trackball import Trackball, TrackballMode\nimport busio as io\n\ni2c = io.I2C(scl=board.D3, sda=board.D2)\ntrackball = Trackball(i2c)\nkeyboard.modules.append(trackball)\n</code></pre> <p>Module will also work when you cannot use <code>busio</code> and do <code>import bitbangio as io</code> instead.</p>"},{"location":"pimoroni_trackball/#key-inputs-other-handler-combinations","title":"Key inputs, other handler combinations","text":"<p>If you have used this thing on a mobile device, you will know it excels at cursor movement</p> <pre><code>\nfrom kmk.modules.pimoroni_trackball import Trackball, TrackballMode, PointingHandler, KeyHandler, ScrollHandler, ScrollDirection\n\ntrackball = Trackball(\n    i2c, \n    mode=TrackballMode.MOUSE_MODE, \n    # optional: set rotation angle of the trackball breakout board, default is 1\n    angle_offset=1.6, \n    handlers=[\n        # act like an encoder, input arrow keys\n        KeyHandler(KC.UP, KC.RIGHT, KC.DOWN, KC.LEFT, KC.ENTER), \n        # on layer 1 and above use the default pointing behavior\n        PointingHandler(),\n        # use ScrollDirection.NATURAL (default) or REVERSE to change the scrolling direction\n        ScrollHandler(scroll_direction=ScrollDirection.NATURAL)\n    ]\n)\n\n# now you can use these KeyCodes:\n\nKC.TB_NEXT_HANDLER # rotates through available \nKC.TB_HANDLER(0) # activate KeyHandler \nKC.TB_HANDLER(1) # activate MouseHandler\n\n</code></pre>"},{"location":"pimoroni_trackball/#backlight","title":"Backlight","text":"<p>Setup backlight color using below commands:</p> <pre><code>trackball.set_rgbw(r, g, b, w)\ntrackball.set_red(brightness)\ntrackball.set_green(brightness)\ntrackball.set_blue(brightness)\ntrackball.set_white(brightness)\n</code></pre> <p>This module exposes one keycode <code>TB_MODE</code>, which on hold switches between <code>MOUSE_MODE</code> and <code>SCROLL_MODE</code>. To choose the default mode, pass it in <code>Trackball</code> constructor.</p>"},{"location":"pimoroni_trackball/#light-animation","title":"Light animation","text":"<p>The trackball has a RGB LED which can be controlled with the RGB extension. Example of very slowly glowing led, almost seamlessly changing colors:</p> <pre><code># initiate the trackball and add the library for the trackball pixel buffer\nfrom kmk.modules.pimoroni_trackball import TrackballPixel\n\n# add rgb extension with animations\nfrom kmk.extensions.rgb import RGB, AnimationModes\n\n# pass the pixel buffer to the rgb extension and declare pixel pin None\npixels = TrackballPixel(trackball)\n\n# set the rgb animation configuration to your taste\nrgb = RGB(pixel_pin=None,\n        num_pixels=1,\n        pixels=pixels,\n        hue_default=0,\n        sat_default=255,\n        val_default=255,\n        hue_step=1,\n        sat_step=0,\n        val_step=0,\n        animation_speed=0.5,\n        animation_mode=AnimationModes.SWIRL,\n        )\n\nkeyboard.extensions.append(rgb)\n</code></pre>"},{"location":"porting_to_kmk/","title":"Porting to KMK","text":"<p>Porting a board to KMK is quite simple, and follows this base format.</p> <pre><code>import board\n\nfrom kmk.kmk_keyboard import KMKKeyboard as _KMKKeyboard\nfrom kmk.scanners import DiodeOrientation\n{EXTENSIONS_IMPORT}\n\nclass KMKKeyboard(_KMKKeyboard):\n{REQUIRED}\n    extensions = []\n\n</code></pre>"},{"location":"porting_to_kmk/#required","title":"REQUIRED","text":"<p>This is designed to be replaced with the defining pins of your keyboard. Rows,  columns and the diode direction (if any), should be defined like this</p> <pre><code>    row_pins = [board.p0_31, board.p0_29, board.p0_02, board.p1_15]\n    col_pins = [board.p0_22, board.p0_24, board.p1_00, board.p0_11, board.p1_04]\n    diode_orientation = DiodeOrientation.COL2ROW\n</code></pre>"},{"location":"porting_to_kmk/#additional-pins-for-extensions","title":"Additional pins for extensions","text":"<p>KMK includes built in extensions for RGB and split keyboards, and powersave. If these are applicable on your keyboard/microcontroller, the pins should be added here. Refer to the instructions on the respective extensions page on how to add  them. If not adding any extensions, leave this as an empty list as shown.</p>"},{"location":"porting_to_kmk/#coord-mapping","title":"Coord mapping","text":"<p>If your keyboard is not built electrically as a square (though most are), you can provide a mapping directly. An example of this is the  Corne. That has 12 columns for 3 rows, and 6  columns for the bottom row. Split keyboards count as the total keyboard, not per  side, the right side being offset by the number of keys on the left side, as if the rows were stacked. That would look like this:</p> <pre><code>coord_mapping = [\n 0,  1,  2,  3,  4,  5,  24, 25, 26, 27, 28, 29,\n 6,  7,  8,  9, 10, 11,  30, 31, 32, 33, 34, 35,\n12, 13, 14, 15, 16, 17,  36, 37, 38, 39, 40, 41,\n            21, 22, 23,  42, 43, 44,\n]\n</code></pre> <p>Note: Not all numbers are necessarily used ! The keyboard assumes <code>number of line * number of rows</code> keys. Some of the possible keys might not be used. For example a keyboard with 60 keys might have 8 rows, 8 cols, allowing 64 total combinations -- hence 64 keys. 4 numbers will then not be used for keys in the <code>coord_mapping</code> (might be anyone of them depending of the wiring).</p>"},{"location":"porting_to_kmk/#find-your-coord_mapping","title":"Find your <code>coord_mapping</code>","text":"<p>The following code will help you setup your <code>coord_mapping</code> by having every key send its corresponding number. Use it after your pins and module definition to define both <code>keyboard.coord_mapping</code> and <code>keyboard.keymap</code>.</p> <pre><code>from kmk.modules.macros import Macros\nfrom kmk.keys import KC\n\nkeyboard.modules.append(Macros())\n\n# *2 for split keyboards, which will typically manage twice the number of keys\n# of one side. Having this N too large will have no impact (maybe slower boot..)\nN = len(keyboard.col_pins) * len(keyboard.row_pins) * 2\n\nkeyboard.coord_mapping = list(range(N))\n\nlayer = []\n\nfor i in range(N):\n    c, r = divmod(i, 100)\n    d, u = divmod(r, 10)\n    layer.append(\n        KC.MACRO(\n            getattr(KC, 'N' + str(c)),\n            getattr(KC, 'N' + str(d)),\n            getattr(KC, 'N' + str(u)),\n            KC.SPC,\n        )\n    )\nkeyboard.keymap = [layer]\n\nif __name__ == '__main__':\n    keyboard.go()\n</code></pre>"},{"location":"porting_to_kmk/#keymaps","title":"Keymaps","text":"<p>Keymaps are organized as a list of lists. Keycodes are added for every key on  each layer. See keycodes for more details on what keycodes are  available. If using layers or other extensions, also refer to the extensions  page for additional keycodes.</p> <pre><code>from kb import KMKKeyboard\nfrom kmk.keys import KC\n\nkeyboard = KMKKeyboard()\n\nkeyboard.keymap = [\n    [KC.A, KC.B],\n    [KC.C, KC.D],\n]\n\nif __name__ == '__main__':\n    keyboard.go()\n</code></pre>"},{"location":"porting_to_kmk/#more-information","title":"More information","text":"<p>More information on keymaps can be found in the config and keymap documentation.</p>"},{"location":"power/","title":"Power(save)","text":"<p>This module allows you to save power and is targeted to Bluetooth/battery based keyboards.</p>"},{"location":"power/#keycodes","title":"Keycodes","text":"Key Description <code>KC.PS_TOG</code> Toggles powersave on/off <code>KC.PS_ON</code> Turns powersave on <code>KC.PS_OFF</code> Turns powersave off"},{"location":"power/#enabling-the-extension","title":"Enabling the extension","text":"<p>To turn on basic power saving, this is all that is required.</p> <pre><code>from kmk.modules.power import Power\n\npower = Power()\n\nkeyboard.modules.append(power)\n\n</code></pre>"},{"location":"power/#optional-extra-power-saving","title":"Optional extra power saving","text":"<p>On supported boards, such as the nice!nano, power can be cut on VCC saving extra power if OLEDS or RGBs are installed. These drain power even when off, so this will prevent them from doing so. </p> <pre><code>from kmk.modules.power import Power\n\n# Your kb.py may already have this set. If not, add it like this\n# import board\n# keyboard.powersave_pin = board.P0_13\npower = Power(powersave_pin=keyboard.powersave_pin)\n\nkeyboard.modules.append(power)\n\n</code></pre> <p>Make sure that the pin is correct for your microcontroller. The example is for  the nice!nano. Not all microcontrollers have this feature and this can be omitted if not and there will simply be less power saving.</p>"},{"location":"quickpin/","title":"Quickpin","text":"<p>Quickpin helps to quickly translate the pinout between boards of similar footprint. This lets you write a single <code>kb.py</code> that can be swapped between microcontrollers with only a single line change and less mistakes. </p>"},{"location":"quickpin/#supported-footprintsboards","title":"Supported footprints/boards","text":"<ul> <li>Pro micro footprint:</li> <li>SparkFun Pro micro RP2040 SparkFun</li> <li>Boardsource Blok Boardsource</li> <li>Nice!nano NiceKeyboards</li> <li>Adafruit KB2040 Adafruit</li> <li>0xCB Helios keeb.supply</li> <li>Frood 42keebs</li> <li>Elite-Pi 1upkeyboards, Keeb.io, splitkb</li> </ul>"},{"location":"quickpin/#pro-micro-footprint-pinout","title":"Pro micro footprint pinout","text":""},{"location":"quickpin/#example","title":"Example","text":"<p>In this example, we are converting a Boardsource 3x4 from a hard pinned nice!nano to a controller agnostic pinout.</p> <pre><code>row_pins = (board.P1_15, board.P0_02, board.P0_29)\ncol_pins = (board.P0_09, board.P0_10, board.P1_11, board.P1_13)\n</code></pre> <p>Converts to the following. Notice that <code>nice_nano</code> can be subbed for <code>boardsource_blok</code> or <code>sparkfun_promicro_rp2040</code>, or any other board sharing this pinout.</p> <pre><code>from kmk.quickpin.pro_micro.nice_nano import pinout as pins\n\nrow_pins = (pins[16], pins[17], pins[18])\ncol_pins = (pins[12], pins[13], pins[14], pins[15])\n</code></pre>"},{"location":"quickpin/#porting-from-avr-pro-micro","title":"Porting from AVR pro micro","text":"<p>An additional added convenience for translating from another firmware with AVR pro micros has also been added to speed up porting.</p> <pre><code>from kmk.quickpin.pro_micro.nice_nano import pinout as pins\nfrom kmk.quickpin.pro_Micro.avr_promicro import translate as avr\n\nrow_pins = (\n    pins[avr['F7']],\n    pins[avr['F6']],\n    pins[avr['F5']],\n)\ncol_pins = (\n    pins[avr['B6']],\n    pins[avr['B2']],\n    pins[avr['B3']],\n    pins[avr['B1']],\n)\n</code></pre>"},{"location":"quickpin/#adding-boards-to-quickpin-support","title":"Adding boards to Quickpin support","text":"<p>Quickpin format is simply a list of pins in order of all through hole pins, going anticlockwise starting at the top left. The orientation should be with the chips facing toward you, with USB facing the top. If this isn't applicable, or otherwise is not true, it should be stated in a comment in the file. Any pin that is not addressable in software should be left as <code>None</code> to fill the space, and align pins correctly for all boards. All boards should be stored in  <code>kmk/quickpin/&lt;footprint&gt;/boardname.py</code>.</p> <p>Pro Micro RP2040 shown as an example:</p> <pre><code>import board\n\npinout = [\n    board.TX,\n    board.RX,\n    None,  # GND\n    None,  # GND\n    board.D2,\n    board.D3,\n    board.D4,\n    board.D5,\n    board.D6,\n    board.D7,\n    board.D8,\n    board.D9,\n    board.D21,\n    board.MOSI,\n    board.MISO,\n    board.SCK,\n    board.D26,\n    board.D27,\n    board.D28,\n    board.D29,\n    None,  # 3.3v\n    None,  # RST\n    None,  # GND\n    None,  # RAW\n]\n\n</code></pre>"},{"location":"rapidfire/","title":"RapidFire","text":"<p>The RapidFire module lets a user send repeated key taps while a key is held.</p> <p>Some instances where this may be useful are:</p> <ul> <li>MMOs and other games where you are encouraged to repeatedly spam a key</li> <li>More responsive volume up and volume down</li> <li>Faster cursor key navigation</li> <li>Combine with the Mouse Keys module to create rapid-fire mouse clicks</li> <li>Anywhere else you may need an ergonomic alternative to repetitive key tapping</li> </ul>"},{"location":"rapidfire/#keycodes","title":"Keycodes","text":"Key Description <code>KC.RF(kc)</code> Repeatedly sends the specified keycode while pressed"},{"location":"rapidfire/#usage","title":"Usage","text":"<p>Each repeat counts as one full cycle of pressing and releasing. RapidFire works with modifiers (i.e., holding Shift plus a RapidFire key will repeatedly send the shifted version of that RapidFire key) and chaining (i.e., <code>KC.RF(KC.LSHIFT(KC.A))</code>. Multiple RapidFire keys can be held down at the same time, and their timers work independently of each other.</p> <p>The RapidFire keycode has a few different options:</p> Option Default Value Description <code>interval</code> <code>100</code> The time between key taps sent in milliseconds. Note: <code>10</code> appears to be the minimum effective value. <code>timeout</code> <code>200</code> The amount of time in milliseconds the key must be held down before RapidFire activates. Useful if you want to be able to type with keys that have a low <code>interval</code> value. A value of <code>0</code> will result in no waiting period. <code>enable_interval_randomization</code> <code>False</code> Enable randomizing the value of <code>interval</code>. Useful for making the repetitive input look human in instances where you may be flagged as a bot otherwise. <code>randomization_magnitude</code> <code>15</code> If <code>enable_interval_randomization</code> is <code>True</code>, the time between key taps sent will be <code>interval</code> plus or minus a random value up to this amount. <code>toggle</code> <code>False</code> If set to <code>True</code>, activating RapidFire will toggle it on or off. Useful if you don't want to have to keep the button held. Set <code>timeout</code> to <code>0</code> if you would like to toggle on tap."},{"location":"rapidfire/#example-code","title":"Example Code","text":"<pre><code>from kmk.modules.rapidfire import RapidFire\n\nkeyboard.modules.append(RapidFire())\n\n# After 200 milliseconds, repeatedly send Shift+A every 75-125 milliseconds while the button is held\nSPAM_A = KC.RF(KC.LSFT(KC.A), timeout=200, interval=100, enable_interval_randomization=True, randomization_magnitude=25)\n# Immediately toggle repeatedly sending Enter every 50 milliseconds on tap\nSPAM_ENTER = KC.RF(KC.ENT, toggle=True, timeout=0, interval=50)\n\n\nkeyboard.keymap = [[\n    SPAM_A, SPAM_ENTER\n    ]]\n\n</code></pre>"},{"location":"rgb/","title":"RGB/Underglow/NeoPixel","text":"<p>Want your keyboard to shine? Add some lights!</p>"},{"location":"rgb/#circuitpython","title":"CircuitPython","text":"<p>This does require the NeoPixel library from Adafruit. It is part of the Adafruit CircuitPython Bundle. Simply put this in the \"root\" of your CircuitPython device. If unsure, it's the folder with <code>main.py</code> in it, and should be the first folder you see when you open the device.</p> <p>Currently we support the following addressable LEDs:</p> <ul> <li>WS2811, WS2812, WS2812B, WS2812C, etc.</li> <li>SK6812, SK6812MINI, SK6805</li> </ul>"},{"location":"rgb/#color-selection","title":"Color Selection","text":"<p>KMK uses Hue, Saturation, and Value to select colors rather than RGB. The color wheel below demonstrates how this works.</p> <p>Changing the Hue cycles around the circle. Changing the Saturation moves between the inner and outer sections of the wheel, affecting the intensity of the color. Changing the Value sets the overall brightness.</p>"},{"location":"rgb/#enabling-the-extension","title":"Enabling the extension","text":"<p>The only required values that you need to give the RGB extension would be the board pin for the data line, and the number of pixels/LED's. If using a split keyboard, this number is per side, and not the total of both sides.</p> <pre><code>import board\nfrom kmk.extensions.RGB import RGB\n\nrgb = RGB(pixel_pin=board.GP14, num_pixels=27)\nkeyboard.extensions.append(rgb)\n</code></pre>"},{"location":"rgb/#keycodes","title":"[Keycodes]","text":"Key Aliases Description <code>KC.RGB_TOG</code> Toggles RGB <code>KC.RGB_HUI</code> Increase Hue <code>KC.RGB_HUD</code> Decrease Hue <code>KC.RGB_SAI</code> Increase Saturation <code>KC.RGB_SAD</code> Decrease Saturation <code>KC.RGB_VAI</code> Increase Value <code>KC.RGB_VAD</code> Decrease Value <code>KC.RGB_ANI</code> Increase animation speed <code>KC.RGB_AND</code> Decrease animation speed <code>KC.RGB_MODE_PLAIN</code> <code>RGB_M_P</code> Static RGB <code>KC.RGB_MODE_BREATHE</code> <code>RGB_M_B</code> Breathing animation <code>KC.RGB_MODE_RAINBOW</code> <code>RGB_M_R</code> Rainbow animation <code>KC.RGB_MODE_BREATHE_RAINBOW</code> <code>RGB_M_BR</code> Breathing rainbow animation <code>KC.RGB_MODE_KNIGHT</code> <code>RGB_M_K</code> Knight Rider animation <code>KC.RGB_MODE_SWIRL</code> <code>RGB_M_S</code> Swirl animation"},{"location":"rgb/#configuration","title":"Configuration","text":"Define Default Description <code>rgb.num_pixels</code> The number of LEDs connected <code>rgb.rgb_order</code> <code>(1, 0, 2)</code> The order of the pixels R G B, and optionally white. Example(1, 0, 2, 3) <code>rgb.hue_step</code> <code>10</code> The number of steps to cycle through the hue by <code>rgb.sat_step</code> <code>17</code> The number of steps to change the saturation by <code>rgb.val_step</code> <code>17</code> The number of steps to change the brightness by <code>rgb.hue_default</code> <code>0</code> The default hue when the keyboard boots <code>rgb.sat_default</code> <code>255</code> The default saturation when the keyboard boots <code>rgb.val_default</code> <code>255</code> The default value (brightness) when the keyboard boots <code>rgb.val_limit</code> <code>255</code> The maximum brightness level"},{"location":"rgb/#built-in-animation-configuration","title":"Built-in Animation Configuration","text":"Define Default Description <code>rgb.breathe_center</code> <code>1.5</code> Used to calculate the curve for the breathing animation. Anywhere from 1.0 - 2.7 is valid <code>rgb.knight_effect_length</code> <code>4</code> The number of LEDs to light up for the \"Knight\" animation"},{"location":"rgb/#functions","title":"Functions","text":"<p>If you want to create your own animations, or for example, change the lighting in a macro, or a layer switch, here are some functions that are available.</p> Function Description <code>rgb.set_hsv_fill(hue, sat, val)</code> Fills all LED's with HSV values <code>rgb.set_hsv(hue, sat, val, index)</code> Sets a single LED with HSV value <code>rgb.set_rgb_fill((r, g, b))</code> Fills all LED's with RGB(W) values <code>rgb.set_rgb((r, g, b), index)</code> Set's a single LED with RGB(W) values <code>rgb.increase_hue(step)</code> Increases hue by a given step <code>rgb.decrease_hue(step)</code> Decreases hue by a given step <code>rgb.increase_sat(step)</code> Increases saturation by a given step <code>rgb.decrease_sat(step)</code> Decreases saturation by a given step <code>rgb.increase_val(step)</code> Increases value (brightness) by a given step <code>rgb.decrease_val(step)</code> Decreases value (brightness) by a given step <code>rgb.increase_ani()</code> Increases animation speed by 1. Maximum 10 <code>rgb.decrease_ani()</code> Decreases animation speed by 1. Minimum 10 <code>rgb.off()</code> Turns all LED's off <code>rgb.show()</code> Displays all stored configuration for LED's"},{"location":"rgb/#direct-variable-access","title":"Direct variable access","text":"Define Default Description <code>rgb.hue</code> <code>0</code> Sets the hue from 0-255 <code>rgb.sat</code> <code>255</code> Sets the saturation from 0-255 <code>rgb.val</code> <code>255</code> Sets the brightness from 0-255 <code>rgb.reverse_animation</code> <code>False</code> If true, some animations will run in reverse. Can be safely used in user animations <code>rgb.animation_mode</code> <code>static</code> This can be changed to any modes included, or to something custom for user animations. Any string is valid <code>rgb.animation_speed</code> <code>1</code> Increases animation speed of most animations. Recommended 1-5, Maximum 10. <pre><code>from kmk.extensions.rgb import AnimationModes\nrgb = RGB(pixel_pin=rgb_pixel_pin,\n        num_pixels=27\n        val_limit=100,\n        hue_default=0,\n        sat_default=100,\n        rgb_order=(1, 0, 2),  # GRB WS2812\n        val_default=100,\n        hue_step=5,\n        sat_step=5,\n        val_step=5,\n        animation_speed=1,\n        breathe_center=1,  # 1.0-2.7\n        knight_effect_length=3,\n        animation_mode=AnimationModes.STATIC,\n        reverse_animation=False,\n        refresh_rate=60,\n        )\n</code></pre>"},{"location":"rgb/#hardware-modification","title":"Hardware Modification","text":"<p>To add RGB LED's to boards that don't support them directly, you will have to add a 3 wires. The power wire will run on 3.3v or 5v (depending on the LED), ground, and data pins will need added to an unused pin on your microcontroller unless your keyboard has specific solder points for them. With those 3 wires connected, set the <code>pixel_pin</code> as described above, and you are ready to use your RGB LED's/NeoPixel.</p>"},{"location":"rgb/#troubleshooting","title":"Troubleshooting","text":""},{"location":"rgb/#incorrect-colors","title":"Incorrect colors","text":"<p>If your colors are incorrect, check the pixel order of your specific LED's. Here are some common ones.  * WS2811, WS2812, WS2812B, WS2812C are all GRB (1, 0, 2)  * SK6812, SK6812MINI, SK6805 are all GRB (1, 0, 2)  * NeoPixels will vary depending on which one you buy. It will be listed on the product page.</p>"},{"location":"rgb/#lights-dont-turn-on","title":"Lights don't turn on","text":"<p>Make sure that your board supports LED backlight by checking for a line with <code>PIXEL_PIN</code>. If it does not, you can add it to your keymap.  If you added the LED's yourself, you will also need to set <code>num_pixels</code> to the number of installed LED's in total.</p>"},{"location":"rgb/#alternate-led-chipsets","title":"Alternate LED chipsets","text":"<p>Not all RGB LEDs are compatible with NeoPixels. To support these, the RGB extension accepts an instance of a <code>Pixelbuf</code>-compatible object as an optional parameter. If supplied, <code>pixel_pin</code> is ignored and the supplied <code>Pixelbuf</code> is used instead of creating a NeoPixel object. The RGB extension will figure out LED count from the pixel buffer length if not passed explicitly.</p> <p>This works easily with APA102 (\"DotStar\") LEDs, but for most other RGB LED chipsets you will need to provide a wrapper to match the expected interface.</p> <p>A simple example using APA102:</p> <pre><code>import adafruit_dotstar\nfrom kmk.extensions.RGB import RGB\nfrom kb import rgb_pixel_pin  # This can be imported or defined manually\n\n_LED_COUNT=12\npixels = adafruit_dotstar.DotStar(board.SCK, board.MOSI, _LED_COUNT)\n\nrgb = RGB(pixel_pin=None, pixels=pixels)\nkeyboard.extensions.append(rgb)\n</code></pre>"},{"location":"rgb/#multiple-pixelbuffer","title":"Multiple PixelBuffer","text":"<p>Similar to alternate drivers, the RGB module supports passing multiple <code>Pixelbuf</code> objects as an iterable.</p> <pre><code>from kmk.extensions.RGB import RGB\n\npixels = (\n    Neopixel(...),\n    DotStar(...),\n    CustomPixelBuf(...)\n)\n\nrgb = RGB(pixel_pin=None, pixels=pixels)\nkeyboard.extensions.append(rgb)\n</code></pre>"},{"location":"scanners/","title":"Scanners","text":"<p>The default key scanner in KMK assumes a garden variety switch matrix, with one diode per switch to prevent ghosting. This doesn't cover all hardware designs though. With macro pads, for example, it is very common to not have a matrix topology at all. Boards like this aren't compatible with the default matrix scanner, so you will need to swap it out with an alternative scanner.</p>"},{"location":"scanners/#keypad-scanners","title":"Keypad Scanners","text":"<p>The scanners in <code>kmk.scanners.keypad</code> wrap the <code>keypad</code> module that ships with CircuitPython and support the same configuration and tuning options as their upstream. You can find out more in the CircuitPython documentation.</p>"},{"location":"scanners/#keypad-matrixscanner","title":"keypad MatrixScanner","text":"<p>This is the default scanner used by KMK. It uses the CircuitPython builtin <code>keypad.KeyMatrix</code>.</p> <pre><code>from kmk.scanners.keypad import MatrixScanner\n\nclass MyKeyboard(KMKKeyboard):\n    def __init__(self):\n        # create and register the scanner\n        self.matrix = MatrixScanner(\n            # required arguments:\n            column_pins=self.col_pins,\n            row_pins=self.row_pins,\n            # optional arguments with defaults:\n            columns_to_anodes=DiodeOrientation.COL2ROW,\n            interval=0.02,  # Debounce time in floating point seconds\n            max_events=64\n        )\n\n</code></pre>"},{"location":"scanners/#keypad-keysscanner","title":"keypad KeysScanner","text":"<p>The <code>keypad.Keys</code> scanner treats individual GPIO pins as discrete keys. To use this scanner, provide a sequence of pins that describes the layout of your board then include it in the initialization sequence of your keyboard class.</p> <pre><code>import board\nfrom kmk.kmk_keyboard import KMKKeyboard\nfrom kmk.scanners.keypad import KeysScanner\n\n\n# GPIO to key mapping - each line is a new row.\n_KEY_CFG = [\n    board.SW3,  board.SW7,  board.SW11, board.SW15,\n    board.SW2,  board.SW6,  board.SW10, board.SW14,\n    board.SW1,  board.SW5,  board.SW9,  board.SW13,\n    board.SW0,  board.SW4,  board.SW8,  board.SW12,\n]\n\n\n# Keyboard implementation class\nclass MyKeyboard(KMKKeyboard):\n    def __init__(self):\n        # create and register the scanner\n        self.matrix = KeysScanner(\n            # require argument:\n            pins=_KEY_CFG,\n            # optional arguments with defaults:\n            value_when_pressed=False,\n            pull=True,\n            interval=0.02,  # Debounce time in floating point seconds\n            max_events=64\n        )\n</code></pre>"},{"location":"scanners/#keypad-shiftregisterkeys","title":"keypad ShiftRegisterKeys","text":"<p>This scanner can read keys attached to a parallel-in serial-out shift register like the 74HC165 or CD4021. Note that you may chain shift registers to load in as many values as you need.</p> <pre><code>from kmk.scanners.keypad import ShiftRegisterKeys\n\nclass MyKeyboard(KMKKeyboard):\n    def __init__(self):\n        # create and register the scanner\n        self.matrix = ShiftRegisterKeys(\n            # require arguments:\n            clock=board.GP0,\n            data=board.GP1,\n            latch=board.GP2,\n            key_count=8,\n            # optional arguments with defaults:\n            value_to_latch=True, # 74HC165: True, CD4021: False\n            value_when_pressed=False,\n            interval=0.02,  # Debounce time in floating point seconds\n            max_events=64\n        )\n</code></pre>"},{"location":"scanners/#digitalio-scanners","title":"Digitalio Scanners","text":""},{"location":"scanners/#digitalio-matrixscanner","title":"digitalio MatrixScanner","text":"<p>The digitalio Matrix can scan over, as the name implies, <code>digitalio.DigitalInOut</code> objects. That is especially useful if a matrix is build with IO-expanders.</p> <pre><code>from kmk.scanners.digitalio import MatrixScanner\n\nclass MyKeyboard(KMKKeyboard):\n    def __init__(self):\n        # create and register the scanner\n        self.matrix = MatrixScanner(\n            cols=self.col_pins,\n            rows=self.row_pins,\n            diode_orientation=self.diode_orientation,\n            pull=digitalio.Pull.DOWN,\n            rollover_cols_every_rows=None, # optional\n        )\n</code></pre>"},{"location":"scanners/#rotary-encoder-scanners","title":"Rotary Encoder Scanners","text":""},{"location":"scanners/#rotaryioencoder","title":"RotaryioEncoder","text":"<p>Matrix events from a quadrature (\"rotary\") encoder?</p> <pre><code>from kmk.scanners.encoder import RotaryioEncoder\n\nclass MyKeyboard(KMKKeyboard):\n    def __init__(self):\n        # create and register the scanner\n        self.matrix = RotaryioEncoder(\n            pin_a=board.GP0,\n            pin_b=board.GP1,\n            # optional\n            divisor=4,\n        )\n</code></pre>"},{"location":"scanners/#scanner-base-class","title":"<code>Scanner</code> base class","text":"<p>If you require a different type of scanner, you can create your own by providing a subclass of <code>Scanner</code>. This is a very simple interface, it only contains a single method, <code>scan_for_changes(self)</code> which returns a key report if one exists, or <code>None</code> otherwise.</p>"},{"location":"scanners/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"scanners/#multiple-scanners","title":"Multiple Scanners","text":"<p>Sometimes a single scanner doesn't cover all hardware configurations. For example: The bulk of the keyboard may be scanned with a matrix scanner, but a couple of additional keys are directly connected to GPIOs. In that case KMK allows you to define multiple scanners. The <code>KMKKeyboard.matrix</code> attribute can either be assigned a single scanner, or a list of scanners. KMK assumes that successive scanner keys are consecutive, and populates <code>KMKKeyboard.coord_mapping</code> accordingly; for convenience you may have to supply a <code>coord_mapping</code> that resembles your physical layout more closely (expanded below).</p> <p>Example:</p> <pre><code>class MyKeyboard(KMKKeyboard):\n    self.matrix = [\n        MatrixScanner(...),\n        KeysScanner(...),\n        # etc...\n    ]\n</code></pre>"},{"location":"scanners/#multiple-scanners-coord_mapping-and-keymap-changes","title":"Multiple Scanners <code>coord_mapping</code> and keymap changes","text":"<p>To add more scanners you need to add onto your <code>coord_mapping</code>.</p> <p>Example:</p> <p><code>coord_mapping</code> with just one <code>MatrixScanner</code> on a 58 key split keyboard:</p> <pre><code>coord_mapping = [\n     0,  1,  2,  3,  4,  5,         35, 34, 33, 32, 31, 30,\n     6,  7,  8,  9, 10, 11,         41, 40, 39, 38, 37, 36,\n    12, 13, 14, 15, 16, 17,         47, 46, 45, 44, 43, 42,\n    18, 19, 20, 21, 22, 23, 29, 59, 53, 52, 51, 50, 49, 48,\n            25, 26, 27, 28,         58, 57, 56, 55, \n    ]\n</code></pre> <p><code>coord_mapping</code> using <code>MatrixScanner</code> and <code>RotaryioEncoder</code> on the same 58 key split keyboard with an encoder on each half:</p> <pre><code>coord_mapping = [\n     0,  1,  2,  3,  4,  5,         37, 36, 35, 34, 33, 32,\n     6,  7,  8,  9, 10, 11,         43, 42, 41, 40, 39, 38,\n    12, 13, 14, 15, 16, 17,         49, 48, 47, 46, 45, 44,\n    18, 19, 20, 21, 22, 23, 29, 61, 55, 54, 53, 52, 51, 50,\n            25, 26, 27, 28,         60, 59, 58, 57,\n            30, 31,                         62, 63 \n    ]\n</code></pre> <p>On the top left side of a standard split keyboard <code>coord_mapping</code>, right below that you see a split keyboard where <code>RotaryioEncoder</code> and <code>MatrixScanner</code> (the default scanner) are used. In the single scanner example, we used to count from 0 to 29 while the top right side starts at 30. With the addition of the encoder scanner, the left side has 2 additional keys making it count up to 31 and the right side would then start at 32 and count to 63. This means that keys 30, 31, 62, and 63 are for encoders. Notice that all of the encoders are at the end of the array, because we put the encoder scanner after the matrix scanner in <code>keyboard.matrix</code>. Therefore, we need to add 4 more key codes in the corresponding places of our <code>keyboard.keymap</code>, they will be used for the encoders.</p>"},{"location":"serialace/","title":"Serial ACE (Arbitrary Code Execution over serial interface)","text":"<p>Caution: This module allows unrestricted, arbitrary code execution on your KMK device. That includes potential exploits, such as keyloggers, and unvetted user code that may result in undesired behavior and/or crashes. This feature is purely experimental in the sense that you probably neither want nor should use it in production. Advanced knowledge of python and the serial console is required, and we will not provide help or support in any way.</p> <p>This module provides an API to run any valid python code on your keyboard and return the result of that code via an additional serial console (not the one you use for the CircuitPython debugger).</p>"},{"location":"serialace/#prerequisite","title":"Prerequisite","text":"<p>Enable the data serial in <code>boot.py</code>, for example by using KMK's builtin boot configurator:</p> <pre><code>from kmk.bootcfg import bootcfg\n\nbootcfg(\n    # ...excerpt\n    cdc_data=True,\n    # ...\n)\n\n</code></pre> <p>Consult the bootcfg documentation for more details.</p>"},{"location":"serialace/#example","title":"Example","text":"<p>Enable the module, just as any other module else:</p> <pre><code>from kmk.modules.serialace import SerialACE\nkeyboard.modules.append(SerialACE())\n</code></pre> <p>Assume the data serial is on <code>/dev/ttyACM1</code>. Depending on your OS settings, it may be necessary to explicitly set the serial device to raw transmission, no echo:</p> <pre><code>stty -F /dev/ttyACM1 raw -echo\n</code></pre>"},{"location":"serialace/#get-the-list-of-active-layers","title":"Get the List of Active Layers","text":"<pre><code>$ echo \"keyboard.active_layers\" &gt; /dev/ttyACM1\n$ cat /dev/ttyACM1\n[0]\n</code></pre>"},{"location":"serialace/#tap-a-key","title":"\"Tap\" a Key","text":"<pre><code>$ echo \"exec('from kmk.keys import KC; keyboard.tap_key(KC.Y)')\" &gt; /dev/ttyACM1\n$ y\n</code></pre>"},{"location":"split_keyboards/","title":"Split Keyboards","text":"<p>Split keyboards are mostly the same as unsplit. Wired UART is fully supported, and testing of Bluetooth splits, though we don't currently offer support for this.</p> <p>Notice that this Split module must be added after the HoldTap module to the keyboard.modules.</p>"},{"location":"split_keyboards/#drive-names","title":"Drive names","text":"<p>As you will have two CircuitPython drives to update regularly, it is advised to rename them to make your life easier.  Follow the instructions on how to rename CIRCUITPY drives while making sure that:  - The left side ends in \"L\",  - the right side ends in \"R\",  - the entire drive name is 11 characters or less! This is a limitation of the filesystem and you will receive an error if you choose a name longer than that.</p> <p>For example: <code>NYQUISTL</code> for the left and <code>NYQUISTR</code> for the right half.</p>"},{"location":"split_keyboards/#wired-uart","title":"Wired UART","text":"<p>Wired connections can use UART over 1 or 2 wires. With 2 wires, you will be able to synchronize the halves allowing additional features in some extensions.</p> <pre><code>from kb import data_pin\nfrom kmk.modules.split import Split, SplitSide\n\nsplit = Split(split_side=SplitSide.LEFT)\nkeyboard.modules.append(split)\n</code></pre>"},{"location":"split_keyboards/#bluetooth-split-aka-no-trrs-currently-in-testing","title":"Bluetooth split (aka no TRRS) [Currently in testing]","text":"<p>Wireless splits are fully featured with 2 way communication allowing all extensions to work 100%.</p> <pre><code>from kb import data_pin\nfrom kmk.modules.split import Split, SplitType, SplitSide\n\n\nsplit = Split(split_type=SplitType.BLE, split_side=SplitSide.LEFT)\nOR\nsplit = Split(split_type=SplitType.BLE, split_side=SplitSide.RIGHT)\nkeyboard.modules.append(split)\n</code></pre>"},{"location":"split_keyboards/#config","title":"Config","text":"<p>Useful config options:</p> <pre><code>split = Split(\n    split_flip=True,  # If both halves are the same, but flipped, set this True\n    split_side=None,  # Sets if this is to SplitSide.LEFT or SplitSide.RIGHT, or use EE hands\n    split_type=SplitType.UART,  # Defaults to UART\n    split_target_left=True,  # Assumes that left will be the one on USB. Set to False if it will be the right\n    uart_interval=20,  # Sets the uarts delay. Lower numbers draw more power\n    data_pin=None,  # The primary data pin to talk to the secondary device with\n    data_pin2=None,  # Second uart pin to allow 2 way communication\n    uart_flip=True,  # Reverses the RX and TX pins if both are provided\n    use_pio=False,  # Use RP2040 PIO implementation of UART. Required if you want to use other pins than RX/TX\n)\n\n</code></pre>"},{"location":"split_keyboards/#split_side","title":"<code>split_side</code>","text":"<p>This tells your microcontroller which side it handles. It's usually not necessary -- defaulting to <code>split_side = None</code> it results in: - Auto detection of the side from the drive name (ending with 'R'/'L'). - The <code>split_target</code> will be overridden. Each side will act as a <code>split_target</code> if connected to a USB host.</p> <p>The default will cover most cases, but you can still choose to set all that manually, if for example: - You want to debug and/or upload to both sides at the same time over USB. Explicitly setting <code>split_side</code> and <code>split_target</code> prevents that both halves consider themselves as <code>split_target</code> when a USB connection is detected. - There are different peripherals on both sides, others than just mirrored the columns (see <code>split_flip</code> section). That means that the most boards with \"flippable\" PCBs do not need this. The following code is not a guideline, but an extraordinary example showing the flexibility of KMK (and would realistically be applicable only in messy handwired keyboards):</p> <pre><code>from storage import getmount\n\nside = SplitSide.RIGHT if str(getmount('/').label)[-1] == 'R' else SplitSide.LEFT\n\nif side == SplitSide.RIGHT:\n    keyboard.col_pins = ...\n    keyboard.row_pins = ...\n    keyboard.diode_orientation = ...\nelse:\n    keyboard.col_pins = ...\n    keyboard.row_pins = ...\n    keyboard.diode_orientation = ...\n\nsplit = Split(\n    split_side=side,\n    target_left=True,\n    ...\n)\n</code></pre> <p>Note: It is best to stay as consistent as possible, but thanks to the <code>coord_mapping</code> feature, none of the <code>col_pins</code>, <code>row_pins</code> and <code>diode_orientation</code> need to be the same for both side. It is however necessary for <code>len(col_pins) * len(row_pins)</code> to be the same to calculate the offset of the key number on the left side correctly.</p>"},{"location":"split_keyboards/#split_flip","title":"<code>split_flip</code>","text":"<p>If your split keyboard uses the same PCB for both sides, but vertically flipped, set this to <code>True</code>, and <code>False</code> otherwise. <code>True</code> means the wiring is the same for both side except that the <code>col_pins</code> are reversed.</p>"},{"location":"split_keyboards/#split_target_left","title":"<code>split_target_left</code>","text":"<p>The \"split_target\" refers to the side that acts as the USB HID.</p> <p>Setting <code>split_side = None</code> (similar to EE HANDS in QMK) this parameter will be overridden.</p>"},{"location":"split_keyboards/#uart_flip","title":"<code>uart_flip</code>","text":"<p>If your boards are connected through the same pins (like GPIO4 of board A to GPIO4 of board B): use <code>uart_flip = True</code>.</p> <p>If your boards are connected through different pins (like GPIO4 of board A to GPIO10 of board B): use <code>uart_flip = False</code>.</p>"},{"location":"split_keyboards/#use_pio","title":"<code>use_pio</code>","text":"<p>If you're using an RP2040 based board and want the split communication to use other pins than the ones with hardware UART support, you can use the PIO implementation. Typical use cases for this are premade boards, made with QMK's bitbanging protocols in mind.</p> <p>In order to enable it, you must:</p> <ul> <li>Install CircuitPython version &gt; 7.2,</li> <li>pass <code>use_pio=True</code> into the <code>Split()</code> constructor.</li> </ul>"},{"location":"split_keyboards/#data_pindata_pin2","title":"<code>data_pin</code>/<code>data_pin2</code>","text":"<p>For UART <code>SplitType</code>: on the <code>split_target</code> side, <code>data_pin</code> is the one use for RX, <code>data_pin2</code> the one for TX.</p>"},{"location":"split_keyboards/#ee-hands-auto-handedness","title":"EE HANDS / AUTO HANDEDNESS","text":"<p>If you want to plug USB in on either side, or are using Bluetooth, this is for you. For this feature to work your CircuitPython drive must be renamed following the guidelines at the beginning of this doc.</p> <p>For wired connections you need to pass the UART pins. For Bluetooth, remove the <code>split_side</code> like this</p> <pre><code># Wired, adjust the pins to fit your hardware\nsplit = Split(data_pin=board.D0,gddata_pin2=board.D1,)\n# Wireless\nsplit = Split(split_type=SplitType.BLE)\n</code></pre>"},{"location":"steno/","title":"Steno","text":"<p>Communicate with stenography software such as Plover over the Gemini PR protocol.</p>"},{"location":"steno/#setup","title":"Setup","text":"<p>You must include the following in <code>boot.py</code> to enable data serial.</p> <pre><code>import usb_cdc\nusb_cdc.enable(data=True)\n</code></pre> <p>Then, instantiate the module as usual and add steno keys to your keymap.</p> <pre><code>from kmk.modules.steno import Steno\nkeyboard.modules.append(Steno())\n</code></pre>"},{"location":"steno/#keys","title":"Keys","text":"<p>The following keys are created for use in your keymap:</p> Keycode Description <code>KC.STN_LS1</code> S1- <code>KC.STN_LS2</code> S2- <code>KC.STN_LT</code> T- <code>KC.STN_LK</code> K- <code>KC.STN_LP</code> P- <code>KC.STN_LW</code> W- <code>KC.STN_LH</code> H- <code>KC.STN_LR</code> R- <code>KC.STN_A</code> A <code>KC.STN_O</code> O <code>KC.STN_AS1</code> * Top-left <code>KC.STN_AS2</code> * Lower-left <code>KC.STN_AS3</code> * Top-right <code>KC.STN_AS4</code> * Lower-right <code>KC.STN_E</code> E <code>KC.STN_U</code> U <code>KC.STN_RF</code> -F <code>KC.STN_RR</code> -R <code>KC.STN_RP</code> -P <code>KC.STN_RB</code> -B <code>KC.STN_RL</code> -L <code>KC.STN_RT</code> -T <code>KC.STN_RS</code> -S <code>KC.STN_RD</code> -D <code>KC.STN_RZ</code> -Z <code>KC.STN_N1</code> Number bar 1 <code>KC.STN_N2</code> Number bar 2 <code>KC.STN_N3</code> Number bar 3 <code>KC.STN_N4</code> Number bar 4 <code>KC.STN_N5</code> Number bar 5 <code>KC.STN_N6</code> Number bar 6 <code>KC.STN_N7</code> Number bar 7 <code>KC.STN_N8</code> Number bar 8 <code>KC.STN_N9</code> Number bar 9 <code>KC.STN_NA</code> Number bar A <code>KC.STN_NB</code> Number bar B <code>KC.STN_NC</code> Number bar C <code>KC.STN_FN</code> Function <code>KC.STN_RES1</code> Reset 2 <code>KC.STN_RES2</code> Reset 1 <code>KC.STN_PWR</code> Power"},{"location":"steno/#connecting-plover","title":"Connecting Plover","text":"<p>Open the Plover configuration to the Machine tab. Set Machine to Gemini PR. Then, under Connection set the Port to the keyboard's serial data interface (this may take some trial and error if you are unsure which one to use). All other settings can be left as their defaults.</p>"},{"location":"sticky_keys/","title":"Sticky Keys","text":"<p>Sticky keys enable you to have keys that stay pressed for a certain time or until another key is pressed and released. If the timeout expires or other keys are pressed, and the sticky key wasn't released, it is handled as a regular key being held. Sticky keys are sometimes also referred to as \"one shot keys\".</p>"},{"location":"sticky_keys/#enable-sticky-keys","title":"Enable Sticky Keys","text":"<pre><code>from kmk.modules.sticky_keys import StickyKeys\nsticky_keys = StickyKeys()\n# optional: set a custom release timeout in ms (default: 1000ms)\n# sticky_keys = StickyKeys(release_after=5000)\nkeyboard.modules.append(sticky_keys)\n</code></pre>"},{"location":"sticky_keys/#keycodes","title":"Keycodes","text":"Keycode Aliases Description <code>KC.SK(KC.ANY)</code> <code>KC.STICKY</code> make a sticky version of <code>KC.ANY</code> <p><code>KC.STICKY</code> accepts any valid key code as argument, including modifiers and KMK internal keys like momentary layer shifts.</p>"},{"location":"sticky_keys/#custom-sticky-behavior","title":"Custom Sticky Behavior","text":"<p>The full sticky key signature is as follows:</p> <pre><code>KC.SK(\n    KC.ANY,              # the key to made sticky\n    defer_release=False  # when to release the key\n    retap_cancel=True    # repeated tap releases the key\n)\n</code></pre>"},{"location":"sticky_keys/#defer_release","title":"<code>defer_release</code>","text":"<p>If <code>False</code> (default): release sticky key after the first interrupting key releases. If <code>True</code>: stay sticky until all keys are released. Useful when combined with non-sticky modifiers, layer keys, etc...</p>"},{"location":"sticky_keys/#repeat_cancel","title":"<code>repeat_cancel</code>","text":"<p>If <code>True</code> (default): Repeated tap releases the key and refreshes timeout. If <code>False</code>: Repeated tap refreshes the timeout.</p>"},{"location":"sticky_keys/#sticky-stacks","title":"Sticky Stacks","text":"<p>Sticky keys can be stacked, i.e. tapping a sticky key within the release timeout of another will reset the timeout off all previously tapped sticky keys and \"stack\" their effects. In this example if you tap <code>SK_LCTL</code> and then <code>SK_LSFT</code> followed by <code>KC.TAB</code>, the output will be <code>ctrl+shift+tab</code>.</p> <pre><code>SK_LCTL = KC.SK(KC.LCTL)\nSK_LSFT = KC.SK(KC.LSFT)\n\nkeyboard.keymap = [[SK_LSFT, SK_LCTL, KC.TAB]]\n</code></pre>"},{"location":"sticky_mod/","title":"Sticky Mod","text":"<p>This module allows to hold a modifier while a key is being tapped repeatedly; the modifier will be released when any other key is pressed or released. This is for example useful if you want to switch between open windows with <code>ALT+TAB</code> or <code>CMD+TAB</code>, using only a single key.</p>"},{"location":"sticky_mod/#enabling-the-module","title":"Enabling the module","text":"<pre><code>from kmk.modules.sticky_mod import StickyMod\nsticky_mod = StickyMod()\nkeyboard.modules.append(sticky_mod)\nkeyboard.keymap = [\n    [\n        KC.SM(key=KC.TAB, mod=KC.LALT),\n        KC.SM(KC.TAB, KC.LSFT(KC.LALT)),\n    ],\n]\n</code></pre>"},{"location":"sticky_mod/#keycodes","title":"Keycodes","text":"Key Description <code>KC.SM(KC.key, KC.mod)</code> sticky mod"},{"location":"string_substitution/","title":"String Substitution","text":"<p>The String Substitution module lets a user replace one typed sequence of characters with another. If a string of characters you type matches an entry in your dictionary, it gets deleted and replaced with the corresponding replacement string.</p> <p>Potential uses:</p> <ul> <li>Rudimentary auto-correct: replace <code>yuo</code> with <code>you</code></li> <li>Text expansion, \u00e0 la espanso: when <code>:sig</code> is typed, replace it with <code>John Doe</code>, or turn <code>idk</code> into <code>I don't know</code></li> </ul>"},{"location":"string_substitution/#usage","title":"Usage","text":"<p>The String Substitution module takes a single argument to be passed during initialization: a user-defined dictionary where the keys are the text to be replaced and the values are the replacement text.</p> <p>Example is as follows:</p> <pre><code>from kmk.modules.string_substitution import StringSubstitution\n\nmy_dictionary = {\n    'yuo': 'you',\n    ':sig': 'John Doe',\n    'idk': \"I don't know\"\n}\nstring_substitution = StringSubstitution(dictionary=my_dictionary)\nkeyboard.modules.append(string_substitution)\n</code></pre>"},{"location":"string_substitution/#recommendations","title":"Recommendations","text":"<ol> <li>Consider prefixing text expansion entries with a symbol to prevent accidental activation: <code>:sig</code>, <code>!email</code>, etc.</li> <li>If you want multiple similar replacements, consider adding a number to prevent unreachable matches: <code>replaceme1</code>, <code>replaceme2</code>, etc.</li> </ol>"},{"location":"string_substitution/#limitations","title":"Limitations","text":"<ol> <li>Currently supports characters for which there is a corresponding keycode in KMK - support for international characters is not implemented.</li> <li>Since this runs on your keyboard, it is not context-aware. It can't tell if you are typing in a valid text field or not.</li> <li>In the interest of a responsive typing experience, the first valid match will be used as soon as it is found. If your dictionary contains <code>abc</code> and <code>abcd</code>, <code>abcd</code> will never match.</li> </ol>"},{"location":"support/","title":"Support","text":"<p>For asynchronous support and chatter about KMK, join our Zulip community!</p> <p>If you ask for help in chat or open a bug report, if possible make sure your copy of KMK is up-to-date. In particular, swing by the Zulip chat before opening a GitHub Issue about configuration, documentation, etc. concerns.</p> <p>The former Matrix and Discord rooms once linked to in this README are no longer officially supported, please do not use them!</p>"},{"location":"tapdance/","title":"Tap Dance","text":"<p>Tap dance is a way to allow a single physical key to work as multiple logical keys / actions without using layers. With basic tap dance, you can trigger these \"nested\" keys or macros through a series of taps of the physical key within a given timeout.</p> <p>The resulting \"logical\" action works just like any other key - it can be pressed and immediately released, or it can be held. For example, let's take a key <code>KC.TD(KC.A, KC.B)</code>. If the tap dance key is tapped and released once quickly, the letter \"a\" will be sent. If it is tapped and released twice quickly, the letter \"b\" will be sent. If it is tapped once and held, the letter \"a\" will be held down until the tap dance key is released. If it is tapped and released once quickly, then tapped and held (both actions within the timeout window), the letter \"b\" will be held down until the tap dance key is released.</p> <p>To use this, you may want to define a <code>tap_time</code> value in your keyboard configuration. This is an integer in milliseconds, and defaults to <code>300</code>. The timeout is reset after each tap and every tap dance sequence can also define an individual <code>tap_time</code>.</p> <p>You'll then want to create a sequence of keys using <code>KC.TD(KC.SOMETHING, KC.SOMETHING_ELSE, MAYBE_THIS_IS_A_MACRO, WHATEVER_YO)</code>, and place it in your keymap somewhere. The only limits on how many keys can go in the sequence are, theoretically, the amount of RAM your MCU/board has.</p> <p>Tap dance supports all <code>HoldTap</code> based keys, like mod tap, layer tap... it will even honor every option set for those keys. Individual timeouts and prefer hold behavior for every tap in the sequence? Not a problem.</p> <p>Here's an example of all this in action:</p> <pre><code>from kmk.keycodes import KC\nfrom kmk.modules.macros import Macros\nfrom kmk.modules.tapdance import TapDance\n\nkeyboard = KMKKeyboard()\n\ntapdance = TapDance()\ntapdance.tap_time = 750\nkeyboard.modules.append(tapdance)\nkeyboard.modules.append(Macros())\n\nEXAMPLE_TD = KC.TD(\n    # Tap once for \"a\"\n    KC.A,\n    # Tap twice for \"b\", or tap and hold for \"left control\"\n    KC.HT(KC.B, KC.LCTL, prefer_hold=False),\n    # Tap three times to send a raw string via macro\n    KC.MACRO('macros in a tap dance? I think yes'),\n    # Tap four times to toggle layer index 1, tap 3 times and hold for 3s to\n    # momentary toggle layer index 1.\n    KC.TT(1, tap_time=3000),\n)\n\n# make the default tap time really short for this tap dance:\nEXAMPLE_TD2 = KC.TD(KC.A, KC.B, tap_time=80)\n\n\nkeyboard.keymap = [[ ...., EXAMPLE_TD, ....], ....]\n</code></pre>"}]}