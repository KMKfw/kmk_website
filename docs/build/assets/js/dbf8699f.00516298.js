"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[6108],{3905:function(e,n,t){t.d(n,{Zo:function(){return l},kt:function(){return u}});var o=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=o.createContext({}),d=function(e){var n=o.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},l=function(e){var n=d(e.components);return o.createElement(p.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),m=d(t),u=r,f=m["".concat(p,".").concat(u)]||m[u]||c[u]||a;return t?o.createElement(f,i(i({ref:n},l),{},{components:t})):o.createElement(f,i({ref:n},l))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=m;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var d=2;d<a;d++)i[d]=t[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5915:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return p},default:function(){return u},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return c}});var o=t(7462),r=t(3366),a=(t(7294),t(3905)),i=["components"],s={},p="Porting to KMK",d={unversionedId:"porting_to_kmk",id:"porting_to_kmk",title:"Porting to KMK",description:"Porting a board to KMK is quite simple, and follows this base format.",source:"@site/docs/porting_to_kmk.md",sourceDirName:".",slug:"/porting_to_kmk",permalink:"/kmk_website/docs/porting_to_kmk",draft:!1,editUrl:"https://github.com/KMKfw/kmk_firmware/tree/master/docs/porting_to_kmk.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Pimoroni Trackball",permalink:"/kmk_website/docs/pimoroni_trackball"},next:{title:"Power(save)",permalink:"/kmk_website/docs/power"}},l={},c=[{value:"REQUIRED",id:"required",level:2},{value:"Additional pins for extensions",id:"additional-pins-for-extensions",level:2},{value:"Keymaps",id:"keymaps",level:2},{value:"More information",id:"more-information",level:2}],m={toc:c};function u(e){var n=e.components,t=(0,r.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"porting-to-kmk"},"Porting to KMK"),(0,a.kt)("p",null,"Porting a board to KMK is quite simple, and follows this base format."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"import board\n\nfrom kmk.kmk_keyboard import KMKKeyboard as _KMKKeyboard\nfrom kmk.scanners import DiodeOrientation\n{EXTENSIONS_IMPORT}\n\nclass KMKKeyboard(_KMKKeyboard):\n{REQUIRED}\n    extensions = []\n\n")),(0,a.kt)("h2",{id:"required"},"REQUIRED"),(0,a.kt)("p",null,"This is designed to be replaced with the defining pins of your keyboard. Rows,\ncolumns and the diode direction (if any), should be defined like this"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"    row_pins = [board.p0_31, board.p0_29, board.p0_02, board.p1_15]\n    col_pins = [board.p0_22, board.p0_24, board.p1_00, board.p0_11, board.p1_04]\n    diode_orientation = DiodeOrientation.COL2ROW\n")),(0,a.kt)("h2",{id:"additional-pins-for-extensions"},"Additional pins for extensions"),(0,a.kt)("p",null,"KMK includes built in extensions for RGB and split keyboards, and powersave. If\nthese are applicable on your keyboard/microcontroller, the pins should be added\nhere. Refer to the instructions on the respective extensions page on how to add\nthem. If not adding any extensions, leave this as an empty list as shown."),(0,a.kt)("h1",{id:"coord-mapping"},"Coord mapping"),(0,a.kt)("p",null,"If your keyboard is not built electrically as a square (though most are), you can\nprovide a mapping directly. An example of this is the\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/foostan/crkbd"},"Corne"),". That has 12 columns for 3 rows, and 6\ncolumns for the bottom row. Split keyboards count as the total keyboard, not per\nside, the right side being offset by the number of keys on the left side, as if\nthe rows were stacked.\nThat would look like this"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"from kmk.scanners import intify_coordinate as ic\n\n    coord_mapping = []\n    coord_mapping.extend(ic(0, x, 6) for x in range(6))\n    coord_mapping.extend(ic(4, x, 6) for x in range(6))\n    coord_mapping.extend(ic(1, x, 6) for x in range(6))\n    coord_mapping.extend(ic(5, x, 6) for x in range(6))\n    coord_mapping.extend(ic(2, x, 6) for x in range(6))\n    coord_mapping.extend(ic(6, x, 6) for x in range(6))\n    # And now, to handle R3, which at this point is down to just six keys\n    coord_mapping.extend(ic(3, x, 6) for x in range(3, 6))\n    coord_mapping.extend(ic(7, x, 6) for x in range(0, 3))\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"intify_coordinate")," is the traditional way to generate key positions.\nHere's an equivalent, maybe visually more explanatory version:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"coord_mapping = [\n 0,  1,  2,  3,  4,  5,  24, 25, 26, 27, 28, 29,\n 6,  7,  8,  9, 10, 11,  30, 31, 32, 33, 34, 35,\n12, 13, 14, 15, 16, 17,  36, 37, 38, 39, 40, 41,\n            21, 22, 23,  42, 43, 44,\n]\n")),(0,a.kt)("h2",{id:"keymaps"},"Keymaps"),(0,a.kt)("p",null,"Keymaps are organized as a list of lists. Keycodes are added for every key on\neach layer. See ",(0,a.kt)("a",{parentName:"p",href:"/kmk_website/docs/keycodes"},"keycodes")," for more details on what keycodes are\navailable. If using layers or other extensions, also refer to the extensions\npage for additional keycodes."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"from kb import KMKKeyboard\nfrom kmk.keys import KC\n\nkeyboard = KMKKeyboard()\n\nkeyboard.keymap = [\n    [KC.A, KC.B],\n    [KC.C, KC.D],\n]\n\nif __name__ == '__main__':\n    keyboard.go()\n")),(0,a.kt)("h2",{id:"more-information"},"More information"),(0,a.kt)("p",null,"More information on keymaps can be found ",(0,a.kt)("a",{parentName:"p",href:"/kmk_website/docs/config_and_keymap"},"here")))}u.isMDXComponent=!0}}]);